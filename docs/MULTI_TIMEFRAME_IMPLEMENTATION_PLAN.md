# 多时间框架实施方案 v3.2.8

## 文档信息

| 项目 | 值 |
|------|-----|
| 版本 | 3.2.8 |
| 创建日期 | 2026-01-26 |
| 更新日期 | 2026-01-26 |
| 基于 | TradingAgents 架构 + AItrader 现有系统 |
| 状态 | **API 合规性修复** (v3.2.8 - request_bars 签名修正 + MultiTimeframeManager 定义) |

## 版本历史

| 版本 | 日期 | 变更内容 |
|------|------|----------|
| v1.0 | 2026-01-26 | 初始方案设计 |
| v2.0 | 2026-01-26 | 根据审查报告修复 API 兼容性问题 |
| v3.0 | 2026-01-26 | 全面仓库审查后修复，合并审查报告，删除冗余文件 |
| v3.1 | 2026-01-26 | **新增完整数据流图** (Section 1.5)，详细描述从数据获取到信号执行的完整流程 |
| v3.2 | 2026-01-26 | **订单流数据增强** (Section 9)，整合 Binance + Coinalyze 数据，含完整 Prompt 设计 |
| v3.2.1 | 2026-01-26 | **Coinalyze API 验证 + 完整配置**，修正 API Key 要求、Symbol 格式、完整 base.yaml 配置 |
| v3.2.2 | 2026-01-26 | **数据格式转换**，添加 Coinalyze → 统一格式转换逻辑，含字段映射表 |
| v3.2.3 | 2026-01-26 | **API 格式实测修正**，根据实际 API 响应修正字段名 (`value` vs `openInterestUsd`) |
| v3.2.4 | 2026-01-26 | **时间戳格式修正**，Coinalyze API 使用 UNIX 秒 (非毫秒)，添加完整 interval 值列表 |
| v3.2.5 | 2026-01-26 | **文档一致性修复**，同步 Section 9.6.2 CoinalyzeClient 的 docstring 与实际 API 格式 |
| v3.2.6 | 2026-01-26 | **服务器实测修正**，时间戳单位不一致 (当前端点毫秒/历史端点秒)，Liquidation 嵌套结构 |
| v3.2.7 | 2026-01-26 | **P0 阻塞项修复**，BarType构建、_prefetch_multi_timeframe_bars()、SMA_200初始化、时间戳标准化 |
| v3.2.8 | 2026-01-26 | **NautilusTrader API 合规性修复**，request_bars 签名修正 (start/end datetime)、新增 MultiTimeframeManager 完整定义 |

### v3.2.8 主要更新 (NautilusTrader API 合规性修复)

1. **P0-NEW-1: `request_bars()` API 签名修正 (严重)**
   - ❌ 错误: `request_bars(bar_type, count=220)` - NautilusTrader 无此参数
   - ✅ 正确: `request_bars(bar_type, start, end, limit)` - 使用 datetime + limit
   - 返回值是 `UUID4`，bars 通过 `on_historical_data()` 回调异步传递
   - 参考: [NautilusTrader Actor.request_bars](https://github.com/nautechsystems/nautilus_trader/blob/develop/nautilus_trader/common/actor.pyx)

2. **P0-NEW-2: `MultiTimeframeManager` 模块定义**
   - 新增 Section 3.3.3 完整类定义 (~200 行)
   - 包含三层 TechnicalIndicatorManager 实例
   - 实现 `route_bar()`, `get_risk_state()`, `set_decision_state()` 方法
   - 文件路径: `indicators/multi_timeframe_manager.py`

3. **P0-NEW-3: `recent_bars` 属性验证** ✅ 已确认
   - `TechnicalIndicatorManager` 已有 `recent_bars: List[Bar]` (line 93)
   - 已有 `is_initialized()` 方法 (line 278-303)
   - 无需修改，仅文档确认

### v3.2.7 主要更新 (P0 阻塞项修复)

1. **P0-1: BarType 构建方式修正**
   - 修正 `BarType.from_str()` 格式字符串
   - 添加备选构造方法注释
   - 格式: `{instrument_id}-{step}-{aggregation}-{price_type}-{aggregation_source}`

2. **P0-2: `_prefetch_multi_timeframe_bars()` 完整实现**
   - 新增完整的历史数据预取方法 (~90 行)
   - 趋势层: 220 根 1D bars (SMA_200 需要)
   - 决策层: 60 根 4H bars (SMA_50 需要)
   - 执行层: 40 根 15M bars (RSI/EMA 需要)
   - 新增 `_verify_mtf_initialization()` 验证方法

3. **P0-3: SMA_200 初始化修正**
   - `_init_managers()` 添加完整参数列表
   - 新增 `is_initialized()` 方法检查各层状态
   - 所有层都传递完整的 `macd_signal`, `bb_std` 等参数

4. **P0-4: 时间戳单位标准化**
   - 新增 `_normalize_timestamp()` 静态方法
   - 处理 Coinalyze 当前端点 (毫秒) vs 历史端点 (秒) 差异
   - 自动检测 10位/13位时间戳
   - `_convert_derivatives()` 统一输出 `timestamp_ms` 字段

5. **数据验证增强**
   - 新增 `_validate_data()` 方法
   - OI 范围检查 (负值、超大值)
   - 价格合理性检查
   - 清算数据验证

### v3.2.6 主要更新 (服务器实测修正)

1. **⚠️ 时间戳单位不一致 (重要发现)**
   - 当前端点 (`/open-interest`, `/funding-rate`): `update` 是**毫秒** (13位)
   - 历史端点参数 (`from`/`to`): **秒** (10位)
   - 历史端点响应 (`t`): **秒** (10位)

2. **⚠️ Liquidation 响应是嵌套结构**
   ```json
   // 实际格式 (嵌套)
   [{"symbol": "...", "history": [{"t": ..., "l": ..., "s": ...}]}]

   // 之前假设 (扁平) - 错误
   [{"t": ..., "l": ..., "s": ...}]
   ```

3. **OI History 返回 OHLC 数据**
   - 包含 `o` (open), `h` (high), `l` (low), `c` (close)
   - 使用 `c` (close) 字段获取 OI 值

4. **代码更新**
   - `get_liquidations()`: 处理嵌套 `history` 数组
   - `_convert_derivatives()`: 正确提取嵌套数据

### v3.2.5 主要更新 (文档一致性修复)

1. **Section 9.6.2 docstring 更新**
   - `get_open_interest()`: 更正返回格式为 `value` (BTC 数量) + `update` (毫秒)
   - `get_funding_rate()`: 更正返回格式为 `value` + `update` (毫秒)
   - `get_liquidations()`: 添加返回格式说明 (`t`, `l`, `s`)

2. **全面审查结论**
   - 当前系统匹配度: 8.5/10
   - NautilusTrader 标准符合度: 89%
   - TradingAgents 设计理念符合度: 87%
   - 数据格式匹配: 文档内部已同步一致

### v3.2.4 主要更新 (时间戳格式修正)

1. **⚠️ 严重 Bug 修复: 时间戳单位错误**
   - Coinalyze API 使用 **UNIX 秒**，不是毫秒!
   - 旧代码: `int(time.time() * 1000)` ❌
   - 新代码: `int(time.time())` ✅
   - 影响: 清算历史、OI 历史等所有 history 端点

2. **完整的 interval 参数值列表** (官方文档确认)
   ```
   1min, 5min, 15min, 30min, 1hour, 2hour, 4hour, 6hour, 12hour, daily
   ```
   - ⚠️ 必须使用完整拼写 (`1hour` 而非 `1h`)

3. **API 响应时间戳**
   - 响应中的 `t` 字段也是 UNIX 秒
   - 例: `"t": 1622548800` (非毫秒)

4. **历史数据保留策略**
   - 日内周期 (1min ~ 12hour): 保留 1500-2000 条，每日删除旧数据
   - 日线周期 (daily): 永久保留

5. **速率限制细节**
   - 40 次/分钟/API Key
   - 超限返回 HTTP 429
   - `Retry-After` header 指示等待秒数

### v3.2.3 主要更新 (API 格式实测修正)

1. **⚠️ 重大发现: 字段名与文档不符**
   - OI 使用 `value` 字段 (非 `openInterestUsd`)
   - Funding Rate 使用 `value` 字段 (非 `fundingRate`)
   - 时间戳使用 `update` 字段 (非 `timestamp`)
   - 清算 interval 必须是 `1hour` (非 `1h`)

2. **OI 单位发现**
   - ⚠️ `value` 字段是 **BTC 数量**，不是 USD!
   - 需要乘以当前价格才能得到 USD 值
   - 已更新 `_convert_derivatives()` 方法处理此转换

3. **更新的代码** (Section 9.6.3)
   - `_convert_derivatives(oi_raw, liq_raw, funding_raw, current_price)` 新增 `current_price` 参数
   - OI: `oi_btc * current_price → total_usd`
   - Funding: `value` → `current` (无 predicted)
   - Liquidation: `interval=1hour` (非 `1h`)

4. **字段映射表更新** (Section 9.6.4)
   - 添加实测验证标记
   - 完整的原始响应示例

### v3.2.2 主要更新 (数据格式转换)

1. **格式转换逻辑** (Section 9.6.3)
   - 新增 `_convert_derivatives()` 方法
   - Coinalyze → 统一格式转换
   - 支持 API 异常时返回 None (降级处理)

2. **OI 变化率计算**
   - Coinalyze 不提供 `change_24h_pct`
   - 使用缓存对比自行计算
   - 首次运行时为 0

3. **字段映射表** (Section 9.6.4)
   - 详细的 Coinalyze 原始格式 vs 统一格式对照
   - API 响应示例

### v3.2.1 主要更新 (API 验证 + 完整配置)

1. **Coinalyze API 调研验证**
   - ⚠️ **需要 API Key** (免费注册获取，非完全免费)
   - Symbol 格式: `BTCUSDT_PERP.A` (A = Binance)
   - 速率限制: 40 次/分钟
   - 更新 CoinalyzeClient 代码支持 API Key 认证

2. **完整配置文档** (Section 9.7)
   - 新增 `~/.env.aitrader` 的 `COINALYZE_API_KEY`
   - 新增 `configs/base.yaml` 完整的 `multi_timeframe` 配置节
   - 新增 `configs/base.yaml` 完整的 `order_flow` 配置节
   - 新增 `configs/production.yaml` 和 `development.yaml` 环境覆盖
   - 新增代码示例读取配置

3. **降级策略**
   - Coinalyze API 失败时使用默认值 (OI=0, 费率=0)
   - 记录警告日志但不中断交易

### v3.2 主要更新 (订单流数据增强)

1. **新增 Section 9: 订单流数据整合** - 完整数据增强方案
   - 9.1 数据源概览 (Binance 免费 + Coinalyze 需 API Key)
   - 9.2 Binance K线完整字段利用 (12 列 → 全部使用)
   - 9.3 Coinalyze 数据整合 (OI, 清算, 资金费率)
   - 9.4 数据处理原则 (简单计算，AI 处理复杂分析)
   - 9.5 DeepSeek Prompt 设计 (优化版 ~600 tokens)
   - 9.6 代码实现模板
   - 9.7 完整配置 (base.yaml + 环境覆盖)

2. **核心设计原则**
   - **简单计算**: 只做简单除法 (buy_ratio = taker_buy / volume)
   - **AI 分析复杂模式**: 让 AI 判断 CVD 趋势、背离等
   - **低成本数据**: Binance (免费) + Coinalyze (免费注册)
   - **结构化输出**: JSON 格式便于解析

### v3.1 主要更新

1. **新增 Section 1.5: 完整数据流** - 包含 9 个子节
   - 1.5.1 总体数据流图
   - 1.5.2 阶段一: 数据获取流程
   - 1.5.3 阶段二: 趋势层分析流程 (1D)
   - 1.5.4 阶段三: 决策层分析流程 (4H) - TradingAgents 核心
   - 1.5.5 阶段四: 执行层确认流程 (15M)
   - 1.5.6 阶段五: 交易执行流程
   - 1.5.7 完整时序图
   - 1.5.8 AI 调用成本分析
   - 1.5.9 状态机转换图

### v3.0 主要更新

1. **删除独立审查报告** - 审查结论合并到本文档
2. **修复 ConfigManager 问题** - 辅助方法不存在，改用直接 `get()` 调用
3. **修复 SMA_200 缺失** - 需要在配置中添加 200 周期
4. **修复 conftest.py 缺失** - 当前测试无 pytest fixtures
5. **简化配置访问** - 移除不存在的辅助方法依赖

---

## 1. 架构概述

### 1.1 时间框架设计

基于用户需求和 TradingAgents 架构，采用三层时间框架：

| 层级 | 周期 | 职责 | 更新频率 | 触发方式 |
|------|------|------|----------|----------|
| **趋势层** | 1D | Risk-On / Risk-Off 判断 | 每日 1 次 | 日线 bar 收盘事件 |
| **决策层** | 4H | 允许做多 / 做空 / 观望 | 每 4 小时 | 4H bar 收盘事件 |
| **执行层** | 5M / 15M | 精确入场、SL、TP | 每 5-15 分钟 | 定时器 + bar 事件 |

### 1.2 决策流程图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           1D 趋势层 (日线收盘时更新)                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  输入: 1D K线数据                                                    │    │
│  │  指标: SMA_200, MACD趋势, 价格位置                                   │    │
│  │  输出: RISK_ON / RISK_OFF                                           │    │
│  │                                                                      │    │
│  │  规则 (v3.0 - 使用现有指标):                                         │    │
│  │  ├─ Price > SMA_200 + MACD > 0 → RISK_ON (可交易)                   │    │
│  │  └─ Price < SMA_200 或 MACD < 0 → RISK_OFF (观望)                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                     │                                        │
│                    RISK_OFF ────────┴──────── RISK_ON                       │
│                        │                          │                          │
│                        ▼                          ▼                          │
│                   [禁止交易]               [进入决策层]                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                                    │
                                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          4H 决策层 (4H bar 收盘时更新)                       │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  输入: 4H K线数据 + 1D 趋势状态                                      │    │
│  │  指标: MACD, RSI_14, BB_20, SMA_20/50                               │    │
│  │                                                                      │    │
│  │  Phase 1: Bull/Bear 辩论 (TradingAgents 架构)                       │    │
│  │  ├─ Bull Agent: 分析 4H 数据中的做多理由                            │    │
│  │  └─ Bear Agent: 分析 4H 数据中的做空理由                            │    │
│  │                                                                      │    │
│  │  Phase 2: Judge 决策                                                 │    │
│  │  └─ 基于辩论结果 + 量化规则，决定方向                               │    │
│  │                                                                      │    │
│  │  输出: ALLOW_LONG / ALLOW_SHORT / WAIT                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      5M/15M 执行层 (定时器触发)                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  输入: 5M/15M K线数据 + 4H 决策方向                                  │    │
│  │  指标: RSI_14, EMA_10, 支撑/阻力                                    │    │
│  │                                                                      │    │
│  │  Phase 3: Risk Manager 评估 (TradingAgents 架构)                    │    │
│  │  └─ 确定: 入场价位、止损、止盈、仓位大小                            │    │
│  │                                                                      │    │
│  │  执行条件检查:                                                       │    │
│  │  ├─ 1D = RISK_ON ✓                                                  │    │
│  │  ├─ 4H = ALLOW_LONG/SHORT ✓                                         │    │
│  │  └─ 15M RSI 未极端 ✓                                                │    │
│  │                                                                      │    │
│  │  输出: 执行交易 或 继续等待                                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.3 与 TradingAgents 架构的对应关系

| TradingAgents 组件 | 当前 AItrader 实现 | 多时间框架改造 |
|-------------------|-------------------|----------------|
| Market Analyst | `TechnicalIndicatorManager` | 扩展为多周期版本 |
| Bull Researcher | `MultiAgentAnalyzer._get_bull_argument()` | 接收 4H 数据 |
| Bear Researcher | `MultiAgentAnalyzer._get_bear_argument()` | 接收 4H 数据 |
| Judge | `MultiAgentAnalyzer._get_judge_decision()` | 基于 4H 决策 |
| Risk Manager | `MultiAgentAnalyzer._evaluate_risk()` | 基于 5M/15M 执行 |
| Trader Agent | `DeepSeekAIStrategy._execute_trade()` | 综合三层信息 |

### 1.4 优先级规则

```python
# 跨层信号优先级: 趋势层 > 决策层 > 执行层
def get_final_action(risk_state, decision_state, execution_confirmed):
    """
    优先级规则:
    1. 趋势层 RISK_OFF → 禁止任何交易
    2. 决策层 WAIT → 等待方向确认
    3. 执行层未确认 → 等待入场时机
    """
    if risk_state == RiskState.RISK_OFF:
        return "NO_TRADE"  # 趋势层否决

    if decision_state == DecisionState.WAIT:
        return "WAIT_DIRECTION"  # 决策层等待

    if not execution_confirmed:
        return "WAIT_ENTRY"  # 执行层等待确认

    # 所有层都确认
    if decision_state == DecisionState.ALLOW_LONG:
        return "EXECUTE_LONG"
    elif decision_state == DecisionState.ALLOW_SHORT:
        return "EXECUTE_SHORT"

    return "HOLD"
```

---

## 1.5 完整数据流 (v3.0 新增)

本节描述从数据获取到信号执行的完整流程，是 v3.0 方案的核心设计。

### 1.5.1 总体数据流图

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                                    完整数据流概览                                            │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                              │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐                                 │
│  │ Binance 1D   │     │ Binance 4H   │     │ Binance 15M  │    ← 数据源层                   │
│  │   K线 API    │     │   K线 API    │     │   K线 API    │                                 │
│  └──────┬───────┘     └──────┬───────┘     └──────┬───────┘                                 │
│         │                    │                    │                                          │
│         ▼                    ▼                    ▼                                          │
│  ┌──────────────────────────────────────────────────────────────────────────┐               │
│  │                    NautilusTrader DataEngine                             │ ← 数据引擎层   │
│  │  subscribe_bars(1D) │ subscribe_bars(4H) │ subscribe_bars(15M)          │               │
│  └──────────────────────────────────────────────────────────────────────────┘               │
│         │                    │                    │                                          │
│         │ on_bar()           │ on_bar()           │ on_bar()                                │
│         ▼                    ▼                    ▼                                          │
│  ┌──────────────────────────────────────────────────────────────────────────┐               │
│  │                    MultiTimeframeManager.route_bar()                     │ ← 路由层      │
│  │         精确匹配 BarType → 分发到对应层                                   │               │
│  └──────────────────────────────────────────────────────────────────────────┘               │
│         │                    │                    │                                          │
│         ▼                    ▼                    ▼                                          │
│  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐                                  │
│  │ trend_      │      │ decision_   │      │ execution_  │                                  │
│  │ manager     │      │ manager     │      │ manager     │    ← 指标管理层                   │
│  │ (SMA_200,   │      │ (SMA20/50,  │      │ (RSI, EMA,  │                                  │
│  │  MACD)      │      │  RSI, MACD, │      │  支撑阻力)  │                                  │
│  │             │      │  BB)        │      │             │                                  │
│  └──────┬──────┘      └──────┬──────┘      └──────┬──────┘                                  │
│         │                    │                    │                                          │
│         │ 日线收盘            │ 4H收盘             │ 15M更新                                  │
│         ▼                    ▼                    ▼                                          │
│  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐                                  │
│  │ 趋势层评估   │      │ 决策层分析   │      │ 执行层确认   │    ← 分析层                      │
│  │             │      │             │      │             │                                  │
│  │ evaluate_   │      │ Bull/Bear   │      │ check_      │                                  │
│  │ risk_state()│      │ Judge 辩论  │      │ execution_  │                                  │
│  │             │      │ (AI调用)    │      │ confirmation│                                  │
│  └──────┬──────┘      └──────┬──────┘      └──────┬──────┘                                  │
│         │                    │                    │                                          │
│         │ RISK_ON/OFF        │ ALLOW_LONG/        │ confirmed:                              │
│         │                    │ SHORT/WAIT         │ true/false                              │
│         ▼                    ▼                    ▼                                          │
│  ┌──────────────────────────────────────────────────────────────────────────┐               │
│  │                      优先级规则 (Priority Rules)                          │ ← 决策层      │
│  │  if RISK_OFF → NO_TRADE                                                  │               │
│  │  elif WAIT → WAIT_DIRECTION                                              │               │
│  │  elif !confirmed → WAIT_ENTRY                                            │               │
│  │  else → EXECUTE_LONG / EXECUTE_SHORT                                     │               │
│  └──────────────────────────────────────────────────────────────────────────┘               │
│                                      │                                                       │
│                                      ▼                                                       │
│  ┌──────────────────────────────────────────────────────────────────────────┐               │
│  │                      交易执行 (_execute_trade)                            │ ← 执行层      │
│  │  • 计算仓位大小                                                           │               │
│  │  • 设置止损止盈                                                           │               │
│  │  • 发送订单到 Binance                                                     │               │
│  │  • 发送 Telegram 通知                                                     │               │
│  └──────────────────────────────────────────────────────────────────────────┘               │
│                                                                                              │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.5.2 阶段一: 数据获取流程

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                              阶段一: 数据获取流程                                            │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                              │
│  启动阶段 (on_start):                                                                        │
│  ═══════════════════════════════════════════════════════════════════════════                │
│                                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐                │
│  │                    DeepSeekAIStrategy.on_start()                        │                │
│  │                                                                          │                │
│  │  if mtf_enabled:                                                        │                │
│  │      # 1. 订阅三个时间框架的 bars                                         │                │
│  │      subscribe_bars(BTCUSDT.BINANCE-1-DAY-LAST-EXTERNAL)     ─┐         │                │
│  │      subscribe_bars(BTCUSDT.BINANCE-4-HOUR-LAST-EXTERNAL)     ├──▶ NautilusTrader       │
│  │      subscribe_bars(BTCUSDT.BINANCE-15-MINUTE-LAST-EXTERNAL) ─┘         DataEngine      │
│  │                                                                          │                │
│  │      # 2. 预取历史数据填充指标 (v3.2.8 修正: 异步 API)                    │                │
│  │      _prefetch_multi_timeframe_bars()                                   │                │
│  │          ├── request_bars(1D, start=220天前, limit=220) → on_historical_data │            │
│  │          ├── request_bars(4H, start=10天前, limit=60)   → on_historical_data │            │
│  │          └── request_bars(15M, start=10小时前, limit=40) → on_historical_data│            │
│  │                                                                          │                │
│  └─────────────────────────────────────────────────────────────────────────┘                │
│                                                                                              │
│  运行阶段 (on_bar):                                                                          │
│  ═══════════════════════════════════════════════════════════════════════════                │
│                                                                                              │
│  Binance WebSocket                 NautilusTrader                Strategy                   │
│       │                                 │                            │                       │
│       │ 1D bar close                    │                            │                       │
│       │ ─────────────────────────────▶  │                            │                       │
│       │                                 │ on_bar(1D_bar)             │                       │
│       │                                 │ ──────────────────────────▶│                       │
│       │                                 │                            │ route_bar()           │
│       │                                 │                            │ → "trend"             │
│       │                                 │                            │                       │
│       │ 4H bar close                    │                            │                       │
│       │ ─────────────────────────────▶  │                            │                       │
│       │                                 │ on_bar(4H_bar)             │                       │
│       │                                 │ ──────────────────────────▶│                       │
│       │                                 │                            │ route_bar()           │
│       │                                 │                            │ → "decision"          │
│       │                                 │                            │                       │
│       │ 15M bar close (每15分钟)        │                            │                       │
│       │ ─────────────────────────────▶  │                            │                       │
│       │                                 │ on_bar(15M_bar)            │                       │
│       │                                 │ ──────────────────────────▶│                       │
│       │                                 │                            │ route_bar()           │
│       │                                 │                            │ → "execution"         │
│       ▼                                 ▼                            ▼                       │
│                                                                                              │
│  数据更新频率:                                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐                     │
│  │ 时间框架 │ 更新频率     │ 数据点/天 │ 指标更新内容                  │                     │
│  ├──────────┼──────────────┼───────────┼──────────────────────────────┤                     │
│  │ 1D       │ 每日 00:00   │ 1         │ SMA_200, MACD (趋势判断)     │                     │
│  │ 4H       │ 每 4 小时    │ 6         │ SMA20/50, RSI, MACD, BB      │                     │
│  │ 15M      │ 每 15 分钟   │ 96        │ RSI, EMA_10, 支撑/阻力       │                     │
│  └────────────────────────────────────────────────────────────────────┘                     │
│                                                                                              │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.5.3 阶段二: 趋势层分析流程 (1D)

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                          阶段二: 趋势层分析流程 (1D)                                         │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                              │
│  触发条件: 日线收盘 (UTC 00:00)                                                              │
│  目的: 判断大趋势，决定是否允许开仓                                                          │
│                                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐                │
│  │                    _on_trend_bar_close(bar)                             │                │
│  │                                                                          │                │
│  │  # 输入                                                                  │                │
│  │  current_price = bar.close  # 日线收盘价                                 │                │
│  │                                                                          │                │
│  │  # 获取技术指标                                                          │                │
│  │  tech_data = trend_manager.get_technical_data(current_price)            │                │
│  │  ┌──────────────────────────────────────────────────────────┐           │                │
│  │  │ tech_data = {                                            │           │                │
│  │  │     'sma_200': 95000.0,    # 200日均线                   │           │                │
│  │  │     'macd': 150.5,         # MACD 值                     │           │                │
│  │  │     'macd_signal': 120.0,  # MACD 信号线                 │           │                │
│  │  │     'macd_histogram': 30.5 # MACD 柱状图                 │           │                │
│  │  │ }                                                        │           │                │
│  │  └──────────────────────────────────────────────────────────┘           │                │
│  │                                                                          │                │
│  │  # 评估规则                                                              │                │
│  │  ┌──────────────────────────────────────────────────────────┐           │                │
│  │  │ 条件 1: current_price > sma_200                          │           │                │
│  │  │         100000 > 95000 = True ✓                          │           │                │
│  │  │                                                          │           │                │
│  │  │ 条件 2: macd > 0                                         │           │                │
│  │  │         150.5 > 0 = True ✓                               │           │                │
│  │  │                                                          │           │                │
│  │  │ 结果: 两个条件都满足 → RISK_ON                           │           │                │
│  │  └──────────────────────────────────────────────────────────┘           │                │
│  │                                                                          │                │
│  │  # 状态更新                                                              │                │
│  │  mtf_manager._risk_state = RiskState.RISK_ON                            │                │
│  │  mtf_manager._risk_state_updated = datetime.utcnow()                    │                │
│  │                                                                          │                │
│  │  # 通知 (可选)                                                           │                │
│  │  if risk_state == RISK_OFF:                                             │                │
│  │      telegram_bot.send("⚠️ [1D] RISK_OFF - 暂停新开仓")                  │                │
│  │                                                                          │                │
│  └─────────────────────────────────────────────────────────────────────────┘                │
│                                                                                              │
│  趋势层决策表:                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐                │
│  │ 价格 vs SMA_200 │ MACD 方向 │ 输出状态   │ 交易影响                     │                │
│  ├─────────────────┼───────────┼────────────┼──────────────────────────────┤                │
│  │ 价格 > SMA_200  │ MACD > 0  │ RISK_ON    │ ✅ 允许开仓                  │                │
│  │ 价格 > SMA_200  │ MACD < 0  │ RISK_OFF   │ ❌ 禁止开仓                  │                │
│  │ 价格 < SMA_200  │ MACD > 0  │ RISK_OFF   │ ❌ 禁止开仓                  │                │
│  │ 价格 < SMA_200  │ MACD < 0  │ RISK_OFF   │ ❌ 禁止开仓                  │                │
│  └─────────────────────────────────────────────────────────────────────────┘                │
│                                                                                              │
│  缓存策略:                                                                                   │
│  • 趋势状态缓存 4 小时 (cache_ttl_hours: 4)                                                 │
│  • 避免在趋势层状态未变时重复评估                                                            │
│                                                                                              │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.5.4 阶段三: 决策层分析流程 (4H) - TradingAgents 核心

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                    阶段三: 决策层分析流程 (4H) - TradingAgents 核心                          │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                              │
│  触发条件: 定时器 (每 15 分钟) + 趋势层为 RISK_ON                                           │
│  目的: 通过 Bull/Bear 辩论确定交易方向                                                       │
│                                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐                │
│  │                    _on_timer_multi_timeframe()                          │                │
│  │                                                                          │                │
│  │  # Step 1: 检查趋势层状态 (门卫)                                         │                │
│  │  risk_state = mtf_manager.get_risk_state()                              │                │
│  │  if risk_state == RISK_OFF:                                             │                │
│  │      log("⚠️ RISK_OFF - 跳过分析")                                       │                │
│  │      return  ─────────────────────────────────────────────▶ [终止]      │                │
│  │                                                                          │                │
│  │  # Step 2: 获取 4H 决策层技术数据                                        │                │
│  │  decision_tech_data = mtf_manager.get_technical_data_for_layer(         │                │
│  │      "decision", current_price                                          │                │
│  │  )                                                                       │                │
│  │                                                                          │                │
│  │  ┌────────────────────────────────────────────────────────────────┐     │                │
│  │  │ decision_tech_data = {                                         │     │                │
│  │  │     'sma_20': 99500,                                           │     │                │
│  │  │     'sma_50': 98000,                                           │     │                │
│  │  │     'rsi': 58.5,                                               │     │                │
│  │  │     'macd': 200.0,                                             │     │                │
│  │  │     'macd_signal': 150.0,                                      │     │                │
│  │  │     'bb_upper': 102000,                                        │     │                │
│  │  │     'bb_middle': 99500,                                        │     │                │
│  │  │     'bb_lower': 97000,                                         │     │                │
│  │  │     'trend_layer_state': 'RISK_ON'  # 附加趋势信息             │     │                │
│  │  │ }                                                              │     │                │
│  │  └────────────────────────────────────────────────────────────────┘     │                │
│  │                                                                          │                │
│  │  # Step 3: 获取情绪数据                                                  │                │
│  │  sentiment_data = _get_sentiment_data()                                 │                │
│  │  ┌────────────────────────────────────────────────────────────────┐     │                │
│  │  │ sentiment_data = {                                             │     │                │
│  │  │     'long_short_ratio': 1.25,      # Binance 多空比            │     │                │
│  │  │     'top_trader_sentiment': 0.6,   # 顶级交易者情绪            │     │                │
│  │  │     'net_sentiment': 'BULLISH'                                 │     │                │
│  │  │ }                                                              │     │                │
│  │  └────────────────────────────────────────────────────────────────┘     │                │
│  │                                                                          │                │
│  └─────────────────────────────────────────────────────────────────────────┘                │
│                                                                                              │
│  Step 4: TradingAgents Bull/Bear/Judge 辩论流程 (核心 AI 调用)                               │
│  ═══════════════════════════════════════════════════════════════════════════                │
│                                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐                │
│  │                    MultiAgentAnalyzer.analyze()                         │                │
│  │                                                                          │                │
│  │  ┌─────────────────────────────────────────────────────────────────┐    │                │
│  │  │               Phase A: Bull Agent (做多论点)                     │    │                │
│  │  │                                                                  │    │                │
│  │  │  Prompt:                                                        │    │                │
│  │  │  "作为 Bull Researcher，基于以下 4H 数据分析做多理由:            │    │                │
│  │  │   - 价格: $100,000                                              │    │                │
│  │  │   - SMA20: $99,500 (价格在上方 ✓)                               │    │                │
│  │  │   - RSI: 58.5 (中性偏多)                                        │    │                │
│  │  │   - MACD: 200 > 信号线 150 (金叉)                               │    │                │
│  │  │   - 趋势层: RISK_ON                                             │    │                │
│  │  │   请提供做多的论据和信心等级。"                                  │    │                │
│  │  │                                                                  │    │                │
│  │  │  Response:                                                      │    │                │
│  │  │  {                                                              │    │                │
│  │  │      "argument": "MACD金叉+价格在SMA上方，上升趋势确认",         │    │                │
│  │  │      "confidence": "HIGH",                                      │    │                │
│  │  │      "key_points": ["MACD金叉", "趋势对齐", "情绪偏多"]          │    │                │
│  │  │  }                                                              │    │                │
│  │  └─────────────────────────────────────────────────────────────────┘    │                │
│  │                              │ AI Call #1                               │                │
│  │                              ▼                                          │                │
│  │  ┌─────────────────────────────────────────────────────────────────┐    │                │
│  │  │               Phase B: Bear Agent (做空论点)                     │    │                │
│  │  │                                                                  │    │                │
│  │  │  Prompt:                                                        │    │                │
│  │  │  "作为 Bear Researcher，基于相同数据分析做空/观望理由:           │    │                │
│  │  │   [相同技术数据]                                                 │    │                │
│  │  │   请提供做空或观望的论据。"                                      │    │                │
│  │  │                                                                  │    │                │
│  │  │  Response:                                                      │    │                │
│  │  │  {                                                              │    │                │
│  │  │      "argument": "RSI接近60，可能遇阻；BB上轨102000有压力",       │    │                │
│  │  │      "confidence": "MEDIUM",                                    │    │                │
│  │  │      "key_points": ["RSI接近超买区", "布林带上轨压力"]           │    │                │
│  │  │  }                                                              │    │                │
│  │  └─────────────────────────────────────────────────────────────────┘    │                │
│  │                              │ AI Call #2                               │                │
│  │                              ▼                                          │                │
│  │  ┌─────────────────────────────────────────────────────────────────┐    │                │
│  │  │               Phase C: Judge 决策                                │    │                │
│  │  │                                                                  │    │                │
│  │  │  Prompt:                                                        │    │                │
│  │  │  "作为 Judge，评估双方论点并做出决策:                            │    │                │
│  │  │                                                                  │    │                │
│  │  │   Bull 论点: [HIGH] MACD金叉，趋势对齐                           │    │                │
│  │  │   Bear 论点: [MEDIUM] RSI接近超买，BB上轨压力                    │    │                │
│  │  │                                                                  │    │                │
│  │  │   量化规则:                                                      │    │                │
│  │  │   - 价格 > SMA_20 → +1 分                                       │    │                │
│  │  │   - MACD 金叉 → +1 分                                           │    │                │
│  │  │   - RSI 在 40-60 → 中性                                         │    │                │
│  │  │                                                                  │    │                │
│  │  │   请给出最终决策: BUY / SELL / HOLD"                            │    │                │
│  │  │                                                                  │    │                │
│  │  │  Response:                                                      │    │                │
│  │  │  {                                                              │    │                │
│  │  │      "signal": "BUY",                                           │    │                │
│  │  │      "confidence": "HIGH",                                      │    │                │
│  │  │      "reasoning": "Bull论点更有说服力，趋势确认，可适度做多"      │    │                │
│  │  │  }                                                              │    │                │
│  │  └─────────────────────────────────────────────────────────────────┘    │                │
│  │                              │ AI Call #3                               │                │
│  │                              ▼                                          │                │
│  │  ┌─────────────────────────────────────────────────────────────────┐    │                │
│  │  │               Phase D: Risk Manager 评估                         │    │                │
│  │  │                                                                  │    │                │
│  │  │  Prompt:                                                        │    │                │
│  │  │  "评估交易风险并确定参数:                                        │    │                │
│  │  │   - 决策: BUY (HIGH confidence)                                 │    │                │
│  │  │   - 当前价格: $100,000                                          │    │                │
│  │  │   - 支撑位: $97,000 (BB下轨)                                    │    │                │
│  │  │   - 阻力位: $102,000 (BB上轨)                                   │    │                │
│  │  │                                                                  │    │                │
│  │  │   请给出: 止损价、止盈价、建议仓位比例"                          │    │                │
│  │  │                                                                  │    │                │
│  │  │  Response:                                                      │    │                │
│  │  │  {                                                              │    │                │
│  │  │      "stop_loss": 98500,                                        │    │                │
│  │  │      "take_profit": 103000,                                     │    │                │
│  │  │      "position_size_ratio": 0.8,                                │    │                │
│  │  │      "risk_assessment": "中等风险，风险回报比 1:2"               │    │                │
│  │  │  }                                                              │    │                │
│  │  └─────────────────────────────────────────────────────────────────┘    │                │
│  │                              │ AI Call #4                               │                │
│  │                              ▼                                          │                │
│  │  ┌─────────────────────────────────────────────────────────────────┐    │                │
│  │  │  最终输出:                                                       │    │                │
│  │  │  multi_agent_result = {                                         │    │                │
│  │  │      'signal': 'BUY',                                           │    │                │
│  │  │      'confidence': 'HIGH',                                      │    │                │
│  │  │      'stop_loss_price': 98500,                                  │    │                │
│  │  │      'take_profit_price': 103000,                               │    │                │
│  │  │      'position_multiplier': 0.8,                                │    │                │
│  │  │      'reasoning': 'Bull论点胜出，趋势对齐，可适度做多'           │    │                │
│  │  │  }                                                              │    │                │
│  │  └─────────────────────────────────────────────────────────────────┘    │                │
│  │                                                                          │                │
│  └─────────────────────────────────────────────────────────────────────────┘                │
│                                                                                              │
│  Step 5: 更新决策层状态                                                                      │
│  ═══════════════════════════════════════════════════════════════════════════                │
│                                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐                │
│  │  signal = multi_agent_result['signal']  # 'BUY'                         │                │
│  │  confidence = multi_agent_result['confidence']  # 'HIGH'                │                │
│  │                                                                          │                │
│  │  if signal == 'BUY':                                                    │                │
│  │      mtf_manager.set_decision_state(DecisionState.ALLOW_LONG, 'HIGH')   │                │
│  │  elif signal == 'SELL':                                                 │                │
│  │      mtf_manager.set_decision_state(DecisionState.ALLOW_SHORT, ...)     │                │
│  │  else:                                                                  │                │
│  │      mtf_manager.set_decision_state(DecisionState.WAIT, ...)            │                │
│  └─────────────────────────────────────────────────────────────────────────┘                │
│                                                                                              │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.5.5 阶段四: 执行层确认流程 (15M)

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                          阶段四: 执行层确认流程 (15M)                                        │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                              │
│  触发条件: 决策层信号为 BUY 或 SELL                                                          │
│  目的: 精确入场时机确认，避免在极端 RSI 时入场                                               │
│                                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐                │
│  │                    check_execution_confirmation()                       │                │
│  │                                                                          │                │
│  │  # 获取执行层技术数据                                                    │                │
│  │  exec_tech_data = execution_manager.get_technical_data(current_price)   │                │
│  │                                                                          │                │
│  │  ┌────────────────────────────────────────────────────────────────┐     │                │
│  │  │ exec_tech_data = {                                             │     │                │
│  │  │     'rsi': 52.3,              # 当前 RSI                       │     │                │
│  │  │     'ema_10': 99800,          # 10周期EMA                      │     │                │
│  │  │     'support': 98500,         # 支撑位                         │     │                │
│  │  │     'resistance': 101500      # 阻力位                         │     │                │
│  │  │ }                                                              │     │                │
│  │  └────────────────────────────────────────────────────────────────┘     │                │
│  │                                                                          │                │
│  │  # RSI 范围检查                                                          │                │
│  │  rsi = 52.3                                                             │                │
│  │  rsi_min = 35  # 配置: rsi_entry_min                                    │                │
│  │  rsi_max = 65  # 配置: rsi_entry_max                                    │                │
│  │                                                                          │                │
│  │  rsi_in_range = (35 <= 52.3 <= 65)  # True ✓                            │                │
│  │                                                                          │                │
│  │  return {                                                               │                │
│  │      'confirmed': True,                                                 │                │
│  │      'rsi': 52.3,                                                       │                │
│  │      'rsi_in_range': True,                                              │                │
│  │      'reason': 'RSI=52.3 在范围[35, 65]内'                              │                │
│  │  }                                                                       │                │
│  │                                                                          │                │
│  └─────────────────────────────────────────────────────────────────────────┘                │
│                                                                                              │
│  执行层决策矩阵:                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐                │
│  │ RSI 范围   │ 决策层信号    │ 执行结果          │ 说明                   │                │
│  ├────────────┼───────────────┼───────────────────┼────────────────────────┤                │
│  │ RSI < 35   │ BUY           │ ⏳ WAIT_ENTRY     │ 超卖，等待回升         │                │
│  │ 35-65      │ BUY           │ ✅ EXECUTE_LONG   │ 正常区间，可以入场     │                │
│  │ RSI > 65   │ BUY           │ ⏳ WAIT_ENTRY     │ 接近超买，等待回调     │                │
│  │ RSI < 35   │ SELL          │ ⏳ WAIT_ENTRY     │ 超卖，不适合做空       │                │
│  │ 35-65      │ SELL          │ ✅ EXECUTE_SHORT  │ 正常区间，可以入场     │                │
│  │ RSI > 65   │ SELL          │ ⏳ WAIT_ENTRY     │ 接近超买，可能反转     │                │
│  └─────────────────────────────────────────────────────────────────────────┘                │
│                                                                                              │
│  等待入场策略:                                                                               │
│  • 当 RSI 超出范围时，不立即入场                                                             │
│  • 每 15 分钟重新检查执行层条件                                                              │
│  • 决策层状态保持 (ALLOW_LONG/SHORT)，直到下次 4H 更新                                      │
│                                                                                              │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.5.6 阶段五: 交易执行流程

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                              阶段五: 交易执行流程                                            │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                              │
│  触发条件: 三层全部确认 (RISK_ON + ALLOW_LONG/SHORT + confirmed)                            │
│                                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐                │
│  │                    _execute_trade(multi_agent_result)                   │                │
│  │                                                                          │                │
│  │  # Step 1: 提取交易参数                                                  │                │
│  │  signal = 'BUY'                                                         │                │
│  │  confidence = 'HIGH'                                                    │                │
│  │  stop_loss = 98500                                                      │                │
│  │  take_profit = 103000                                                   │                │
│  │  position_multiplier = 0.8                                              │                │
│  │                                                                          │                │
│  │  # Step 2: 计算仓位大小                                                  │                │
│  │  ┌────────────────────────────────────────────────────────────────┐     │                │
│  │  │ base_usdt = config.position.base_usdt_amount  # 100 USDT       │     │                │
│  │  │                                                                │     │                │
│  │  │ # 基于信心调整                                                 │     │                │
│  │  │ if confidence == 'HIGH':                                       │     │                │
│  │  │     multiplier = 1.5  # 150 USDT                               │     │                │
│  │  │ elif confidence == 'MEDIUM':                                   │     │                │
│  │  │     multiplier = 1.0  # 100 USDT                               │     │                │
│  │  │ else:                                                          │     │                │
│  │  │     multiplier = 0.5  # 50 USDT                                │     │                │
│  │  │                                                                │     │                │
│  │  │ # 应用 Risk Manager 的仓位建议                                 │     │                │
│  │  │ final_usdt = 150 * 0.8 = 120 USDT                              │     │                │
│  │  │                                                                │     │                │
│  │  │ # 计算数量                                                     │     │                │
│  │  │ quantity = 120 / 100000 * leverage(5) = 0.006 BTC              │     │                │
│  │  └────────────────────────────────────────────────────────────────┘     │                │
│  │                                                                          │                │
│  │  # Step 3: 验证止损位置                                                  │                │
│  │  ┌────────────────────────────────────────────────────────────────┐     │                │
│  │  │ # 止损验证规则 (见 CLAUDE.md 已修复问题 #1)                    │     │                │
│  │  │ if signal == 'BUY':                                            │     │                │
│  │  │     assert stop_loss < current_price  # 98500 < 100000 ✓       │     │                │
│  │  │ elif signal == 'SELL':                                         │     │                │
│  │  │     assert stop_loss > current_price                           │     │                │
│  │  │                                                                │     │                │
│  │  │ # 如果验证失败，使用默认 2% 止损                               │     │                │
│  │  └────────────────────────────────────────────────────────────────┘     │                │
│  │                                                                          │                │
│  │  # Step 4: 创建订单                                                      │                │
│  │  ┌────────────────────────────────────────────────────────────────┐     │                │
│  │  │ order = strategy.order_factory.market(                         │     │                │
│  │  │     instrument_id=BTCUSDT.BINANCE,                             │     │                │
│  │  │     order_side=OrderSide.BUY,                                  │     │                │
│  │  │     quantity=Quantity(0.006, 3),                               │     │                │
│  │  │     time_in_force=TimeInForce.GTC,                             │     │                │
│  │  │     tags=['MTF', 'HIGH_CONF', 'BULL_WIN']                      │     │                │
│  │  │ )                                                              │     │                │
│  │  │                                                                │     │                │
│  │  │ # OCO 止损止盈订单                                             │     │                │
│  │  │ bracket = OCOManager.create_bracket(                           │     │                │
│  │  │     entry_order=order,                                         │     │                │
│  │  │     stop_loss_price=98500,                                     │     │                │
│  │  │     take_profit_price=103000                                   │     │                │
│  │  │ )                                                              │     │                │
│  │  └────────────────────────────────────────────────────────────────┘     │                │
│  │                                                                          │                │
│  │  # Step 5: 提交订单                                                      │                │
│  │  strategy.submit_order(order)                                           │                │
│  │                                                                          │                │
│  │  # Step 6: Telegram 通知                                                 │                │
│  │  ┌────────────────────────────────────────────────────────────────┐     │                │
│  │  │ telegram_bot.send_message_sync(                                │     │                │
│  │  │     f"🚀 [MTF] 开仓信号\n"                                      │     │                │
│  │  │     f"━━━━━━━━━━━━━━━━━━━\n"                                   │     │                │
│  │  │     f"📊 方向: LONG\n"                                         │     │                │
│  │  │     f"💰 数量: 0.006 BTC ($120)\n"                             │     │                │
│  │  │     f"📍 入场: $100,000\n"                                     │     │                │
│  │  │     f"🛑 止损: $98,500 (-1.5%)\n"                              │     │                │
│  │  │     f"🎯 止盈: $103,000 (+3%)\n"                               │     │                │
│  │  │     f"━━━━━━━━━━━━━━━━━━━\n"                                   │     │                │
│  │  │     f"🔥 信心: HIGH\n"                                         │     │                │
│  │  │     f"📈 趋势层: RISK_ON\n"                                    │     │                │
│  │  │     f"📊 决策层: ALLOW_LONG\n"                                 │     │                │
│  │  │     f"⚡ 执行层: RSI=52.3 ✓"                                   │     │                │
│  │  │ )                                                              │     │                │
│  │  └────────────────────────────────────────────────────────────────┘     │                │
│  │                                                                          │                │
│  └─────────────────────────────────────────────────────────────────────────┘                │
│                                                                                              │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.5.7 完整时序图

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                              完整时序图 (一个交易周期)                                       │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                              │
│  时间线:  00:00 ───────────────────────────────────────────────────────────▶ 24:00          │
│                                                                                              │
│  1D层:    ┌───────────────────────────────────────────────────────────────────────┐         │
│           │ 00:00: 日线收盘 → evaluate_risk_state() → RISK_ON                     │         │
│           │        (有效期: 24小时，直到下一个日线收盘)                            │         │
│           └───────────────────────────────────────────────────────────────────────┘         │
│                                                                                              │
│  4H层:    ├────┤    ├────┤    ├────┤    ├────┤    ├────┤    ├────┤                         │
│           00:00    04:00    08:00    12:00    16:00    20:00                                │
│           每个时段可能触发 Bull/Bear/Judge 辩论                                              │
│                                                                                              │
│  15M层:   ┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊┊                      │
│           每15分钟更新一次，检查执行层确认条件                                               │
│                                                                                              │
│  定时器:  ├──────────────┤ (15分钟间隔)                                                     │
│           触发 on_timer → 综合三层分析 → 可能执行交易                                        │
│                                                                                              │
│  ─────────────────────────────────────────────────────────────────────────────────          │
│                                                                                              │
│  详细时序 (以 08:00 定时器触发为例):                                                         │
│                                                                                              │
│  08:00:00  on_timer() 触发                                                                  │
│      │                                                                                       │
│      ├─▶ Step 1: 检查趋势层                                                                 │
│      │   risk_state = get_risk_state() → RISK_ON ✓                                          │
│      │                                                                                       │
│      ├─▶ Step 2: 获取 4H 技术数据                                                           │
│      │   decision_tech_data = get_technical_data_for_layer("decision")                      │
│      │                                                                                       │
│      ├─▶ Step 3: 获取情绪数据                                                               │
│      │   sentiment_data = _get_sentiment_data()                                             │
│      │                                                                                       │
│      ├─▶ Step 4: MultiAgent 分析 (4次 AI 调用)                                              │
│      │   │                                                                                   │
│  08:00:01 │   ├─▶ AI Call #1: Bull Agent (~1s)                                              │
│  08:00:02 │   ├─▶ AI Call #2: Bear Agent (~1s)                                              │
│  08:00:03 │   ├─▶ AI Call #3: Judge Decision (~1s)                                          │
│  08:00:04 │   └─▶ AI Call #4: Risk Manager (~1s)                                            │
│      │                                                                                       │
│      │   Result: {signal: 'BUY', confidence: 'HIGH', ...}                                   │
│      │                                                                                       │
│      ├─▶ Step 5: 更新决策层状态                                                             │
│      │   set_decision_state(ALLOW_LONG, 'HIGH')                                             │
│      │                                                                                       │
│      ├─▶ Step 6: 检查执行层确认                                                             │
│      │   confirmation = check_execution_confirmation()                                      │
│      │   RSI = 52.3 → in range [35, 65] → confirmed: True ✓                                │
│      │                                                                                       │
│      ├─▶ Step 7: 执行交易                                                                   │
│      │   _execute_trade({signal: 'BUY', ...})                                               │
│      │                                                                                       │
│  08:00:05 └─▶ 订单提交完成                                                                  │
│                                                                                              │
│  总耗时: ~5 秒 (主要是 4 次 AI 调用)                                                        │
│                                                                                              │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.5.8 AI 调用成本分析

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                              AI 调用成本分析                                                 │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                              │
│  每次完整分析的 AI 调用:                                                                     │
│  ┌────────────────────────────────────────────────────────────────────────────┐             │
│  │ 阶段              │ AI 调用次数 │ 平均 Token 数 │ DeepSeek 成本估算        │             │
│  ├───────────────────┼─────────────┼───────────────┼──────────────────────────┤             │
│  │ Bull Agent        │ 1           │ ~500          │ $0.0005                  │             │
│  │ Bear Agent        │ 1           │ ~500          │ $0.0005                  │             │
│  │ Judge Decision    │ 1           │ ~800          │ $0.0008                  │             │
│  │ Risk Manager      │ 1           │ ~600          │ $0.0006                  │             │
│  ├───────────────────┼─────────────┼───────────────┼──────────────────────────┤             │
│  │ 单次分析合计      │ 4           │ ~2400         │ ~$0.0024                 │             │
│  └────────────────────────────────────────────────────────────────────────────┘             │
│                                                                                              │
│  每日成本估算 (基于 15 分钟定时器):                                                          │
│  ┌────────────────────────────────────────────────────────────────────────────┐             │
│  │ 场景              │ 分析次数/天 │ 日成本        │ 月成本                   │             │
│  ├───────────────────┼─────────────┼───────────────┼──────────────────────────┤             │
│  │ 全天交易          │ 96          │ $0.23         │ $6.90                    │             │
│  │ RISK_OFF 50%      │ 48          │ $0.12         │ $3.45                    │             │
│  │ 仅活跃时段        │ 24          │ $0.06         │ $1.73                    │             │
│  └────────────────────────────────────────────────────────────────────────────┘             │
│                                                                                              │
│  优化策略:                                                                                   │
│  1. RISK_OFF 时跳过 AI 分析 (已实现)                                                        │
│  2. 决策层状态缓存 (4H 内不重复分析相同数据)                                                 │
│  3. 简化 Prompt 减少 Token 消耗                                                             │
│                                                                                              │
│  与原系统对比:                                                                               │
│  ┌────────────────────────────────────────────────────────────────────────────┐             │
│  │ 系统              │ AI 调用/次  │ 日成本        │ 说明                     │             │
│  ├───────────────────┼─────────────┼───────────────┼──────────────────────────┤             │
│  │ 原系统 (单周期)   │ 4           │ $0.23         │ Bull/Bear/Judge/Risk     │             │
│  │ MTF v3.0          │ 4           │ $0.12-0.23    │ 相同，但 RISK_OFF 可跳过 │             │
│  └────────────────────────────────────────────────────────────────────────────┘             │
│                                                                                              │
│  结论: MTF 不增加 AI 调用次数，但通过趋势层过滤可减少无效分析                                │
│                                                                                              │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.5.9 状态机转换图

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                              状态机转换图                                                    │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                              │
│  趋势层状态机:                                                                               │
│  ┌──────────────────────────────────────────────────────────────────────────┐               │
│  │                                                                           │               │
│  │         价格 < SMA_200 或 MACD < 0                                        │               │
│  │         ┌─────────────────────────────────┐                               │               │
│  │         │                                 │                               │               │
│  │         ▼                                 │                               │               │
│  │    ┌─────────┐                      ┌─────────┐                           │               │
│  │    │RISK_OFF │◀─────────────────────│ RISK_ON │                           │               │
│  │    └─────────┘                      └─────────┘                           │               │
│  │         │                                 ▲                               │               │
│  │         │                                 │                               │               │
│  │         └─────────────────────────────────┘                               │               │
│  │         价格 > SMA_200 且 MACD > 0                                        │               │
│  │                                                                           │               │
│  └──────────────────────────────────────────────────────────────────────────┘               │
│                                                                                              │
│  决策层状态机:                                                                               │
│  ┌──────────────────────────────────────────────────────────────────────────┐               │
│  │                                                                           │               │
│  │                   Judge 决策: HOLD                                        │               │
│  │         ┌────────────────────────────────────────────┐                    │               │
│  │         │                                            │                    │               │
│  │         ▼                                            │                    │               │
│  │    ┌──────────┐     Judge: BUY      ┌────────────┐   │                    │               │
│  │    │   WAIT   │ ──────────────────▶ │ ALLOW_LONG │ ──┘                    │               │
│  │    └──────────┘                     └────────────┘                        │               │
│  │         │                                 │                               │               │
│  │         │ Judge: SELL                     │ Judge: SELL                   │               │
│  │         ▼                                 ▼                               │               │
│  │    ┌─────────────┐               ┌──────────┐                             │               │
│  │    │ ALLOW_SHORT │◀──────────────│   WAIT   │                             │               │
│  │    └─────────────┘  Judge: HOLD  └──────────┘                             │               │
│  │         │                                                                 │               │
│  │         └─────────────────────────────────────────────────────────────────┘               │
│  │                           Judge: BUY/HOLD                                 │               │
│  │                                                                           │               │
│  └──────────────────────────────────────────────────────────────────────────┘               │
│                                                                                              │
│  综合决策状态:                                                                               │
│  ┌──────────────────────────────────────────────────────────────────────────┐               │
│  │                                                                           │               │
│  │  ┌─────────┐      ┌─────────────┐      ┌────────────┐      ┌──────────┐  │               │
│  │  │ RISK_OFF│      │ WAIT_       │      │ WAIT_      │      │ EXECUTE_ │  │               │
│  │  │ (禁止)  │      │ DIRECTION   │      │ ENTRY      │      │ TRADE    │  │               │
│  │  └─────────┘      └─────────────┘      └────────────┘      └──────────┘  │               │
│  │       │                 │                    │                   │        │               │
│  │       │ 趋势层=         │ 决策层=            │ 执行层           │ 三层   │               │
│  │       │ RISK_OFF        │ WAIT               │ !confirmed       │ 全部   │               │
│  │       │                 │                    │                  │ 确认   │               │
│  │       ▼                 ▼                    ▼                  ▼        │               │
│  │  [不交易]          [等待方向]           [等待入场]         [执行交易]   │               │
│  │                                                                           │               │
│  └──────────────────────────────────────────────────────────────────────────┘               │
│                                                                                              │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 配置系统改动

### 2.1 新增配置结构 (configs/base.yaml)

```yaml
# =============================================================================
# 多时间框架配置 (Multi-Timeframe Framework) v3.0
# =============================================================================
multi_timeframe:
  enabled: false                      # 默认禁用，确保向后兼容

  # ---------------------------------------------------------------------------
  # 趋势层配置 (1D)
  # ---------------------------------------------------------------------------
  trend_layer:
    timeframe: "1d"
    sma_period: 200                   # SMA200 判断趋势
    require_above_sma: true           # 价格需在 SMA 上方
    require_macd_positive: true       # MACD > 0
    cache_ttl_hours: 4

  # ---------------------------------------------------------------------------
  # 决策层配置 (4H)
  # ---------------------------------------------------------------------------
  decision_layer:
    timeframe: "4h"
    debate_rounds: 2
    include_trend_context: true

  # ---------------------------------------------------------------------------
  # 执行层配置 (5M / 15M)
  # ---------------------------------------------------------------------------
  execution_layer:
    default_timeframe: "15m"
    high_volatility_timeframe: "5m"
    rsi_entry_min: 35                 # RSI 入场范围下限
    rsi_entry_max: 65                 # RSI 入场范围上限
```

### 2.2 配置访问方式 (v3.0 修正)

**重要**: ConfigManager 没有 `is_mtf_enabled()` 等辅助方法，必须使用 `get()` 直接访问。

```python
# v3.0 正确用法 - 直接使用 get()
from utils.config_manager import ConfigManager

config = ConfigManager(env='production')
config.load()

# 检查是否启用
mtf_enabled = config.get('multi_timeframe', 'enabled', default=False)

# 获取趋势层配置
trend_timeframe = config.get('multi_timeframe', 'trend_layer', 'timeframe', default='1d')
trend_sma_period = config.get('multi_timeframe', 'trend_layer', 'sma_period', default=200)

# 获取决策层配置
decision_timeframe = config.get('multi_timeframe', 'decision_layer', 'timeframe', default='4h')
debate_rounds = config.get('multi_timeframe', 'decision_layer', 'debate_rounds', default=2)

# 获取执行层配置
exec_timeframe = config.get('multi_timeframe', 'execution_layer', 'default_timeframe', default='15m')
rsi_entry_min = config.get('multi_timeframe', 'execution_layer', 'rsi_entry_min', default=35)
rsi_entry_max = config.get('multi_timeframe', 'execution_layer', 'rsi_entry_max', default=65)
```

### 2.3 向后兼容配置

当 `multi_timeframe.enabled: false` 时，系统行为与当前版本**完全一致**。

### 2.4 环境特定配置

**configs/production.yaml**:
```yaml
multi_timeframe:
  enabled: true
  execution_layer:
    default_timeframe: "15m"
```

**configs/development.yaml**:
```yaml
multi_timeframe:
  enabled: true
  trend_layer:
    timeframe: "4h"                   # 开发环境使用 4H 代替 1D
  decision_layer:
    timeframe: "1h"                   # 开发环境使用 1H 代替 4H
  execution_layer:
    default_timeframe: "5m"           # 开发环境使用 5M
```

---

## 3. 核心模块改动

### 3.1 新增: MultiTimeframeManager

创建新文件 `indicators/multi_timeframe_manager.py`:

```python
"""
Multi-Timeframe Indicator Manager v3.0

管理多个时间框架的技术指标，提供跨周期分析能力。

v3.0 更新:
- 移除对不存在的 ConfigManager 辅助方法的依赖
- 使用 MACD 替代 ADX (ADX 未在 TechnicalIndicatorManager 实现)
- 添加 SMA_200 支持 (需要在 TechnicalIndicatorManager 初始化时指定)
"""

from typing import Dict, Any, Optional
from enum import Enum
from datetime import datetime
import logging

from nautilus_trader.model.data import Bar, BarType
from indicators.technical_manager import TechnicalIndicatorManager


class RiskState(Enum):
    """趋势层风险状态"""
    RISK_ON = "RISK_ON"       # 可交易
    RISK_OFF = "RISK_OFF"     # 观望


class DecisionState(Enum):
    """决策层方向状态"""
    ALLOW_LONG = "ALLOW_LONG"   # 允许做多
    ALLOW_SHORT = "ALLOW_SHORT" # 允许做空
    WAIT = "WAIT"               # 等待


class MultiTimeframeManager:
    """
    多时间框架管理器 v3.0

    管理三层时间框架:
    - trend_layer (1D): Risk-On/Risk-Off 判断
    - decision_layer (4H): 方向决策
    - execution_layer (5M/15M): 入场执行
    """

    def __init__(
        self,
        config: Dict[str, Any],
        trend_bar_type: Optional[BarType] = None,
        decision_bar_type: Optional[BarType] = None,
        execution_bar_type: Optional[BarType] = None,
        logger: Optional[logging.Logger] = None,
    ):
        """
        初始化多时间框架管理器

        Parameters
        ----------
        config : Dict
            多时间框架配置 (从 ConfigManager.get('multi_timeframe') 获取)
        trend_bar_type : BarType
            趋势层 BarType (用于精确匹配)
        decision_bar_type : BarType
            决策层 BarType
        execution_bar_type : BarType
            执行层 BarType
        logger : Logger
            日志记录器
        """
        self.config = config
        self.enabled = config.get('enabled', False)
        self.logger = logger or logging.getLogger(__name__)

        # 存储 BarType 用于精确匹配
        self.trend_bar_type = trend_bar_type
        self.decision_bar_type = decision_bar_type
        self.execution_bar_type = execution_bar_type

        if not self.enabled:
            self.logger.info("MultiTimeframeManager: disabled")
            return

        # 初始化三层指标管理器
        self.trend_manager: Optional[TechnicalIndicatorManager] = None
        self.decision_manager: Optional[TechnicalIndicatorManager] = None
        self.execution_manager: Optional[TechnicalIndicatorManager] = None

        # 状态缓存
        self._risk_state: RiskState = RiskState.RISK_OFF
        self._risk_state_updated: Optional[datetime] = None

        self._decision_state: DecisionState = DecisionState.WAIT
        self._decision_confidence: str = "LOW"
        self._decision_updated: Optional[datetime] = None

        # 上次更新的价格
        self._last_trend_price: float = 0.0
        self._last_decision_price: float = 0.0
        self._last_execution_price: float = 0.0

        # 初始化各层管理器
        self._init_managers()

        self.logger.info("MultiTimeframeManager: initialized with 3 layers")

    def _init_managers(self):
        """
        初始化各层技术指标管理器

        ⚠️ v3.2.7 修正: 必须传递所有必需参数，确保指标正确初始化
        TechnicalIndicatorManager 参数参考 indicators/technical_manager.py:29-40
        """
        trend_config = self.config.get('trend_layer', {})
        decision_config = self.config.get('decision_layer', {})
        exec_config = self.config.get('execution_layer', {})

        # ========================================
        # 趋势层 (1D) - 需要 SMA_200 用于趋势判断
        # ⚠️ 关键: SMA_200 需要至少 200 根 bar 才能计算
        # ========================================
        sma_period = trend_config.get('sma_period', 200)
        self.trend_manager = TechnicalIndicatorManager(
            sma_periods=[sma_period],      # SMA_200 用于趋势判断
            ema_periods=[12, 26],          # MACD 需要的 EMA
            rsi_period=14,
            macd_fast=12,
            macd_slow=26,
            macd_signal=9,                 # ⚠️ v3.2.7: 必须指定 signal 周期
            bb_period=20,                  # BB 用于波动率参考
            bb_std=2.0,
            volume_ma_period=20,
            support_resistance_lookback=20,
        )
        self.logger.debug(f"趋势层管理器初始化: SMA_{sma_period}")

        # ========================================
        # 决策层 (4H) - Bull/Bear 辩论使用的指标
        # ========================================
        self.decision_manager = TechnicalIndicatorManager(
            sma_periods=[20, 50],          # SMA_20, SMA_50
            ema_periods=[12, 26],
            rsi_period=14,
            macd_fast=12,
            macd_slow=26,
            macd_signal=9,
            bb_period=20,
            bb_std=2.0,
            volume_ma_period=20,
            support_resistance_lookback=20,
        )
        self.logger.debug("决策层管理器初始化")

        # ========================================
        # 执行层 (5M/15M) - 入场确认指标
        # ========================================
        self.execution_manager = TechnicalIndicatorManager(
            sma_periods=[5, 20],
            ema_periods=[10, 20],          # 短周期 EMA
            rsi_period=14,
            macd_fast=12,
            macd_slow=26,
            macd_signal=9,
            bb_period=20,
            bb_std=2.0,
            volume_ma_period=20,
            support_resistance_lookback=20,
        )
        self.logger.debug("执行层管理器初始化")

    def is_initialized(self, layer: str = None) -> bool:
        """
        ⚠️ v3.2.7 新增: 检查指标管理器是否已初始化

        Parameters
        ----------
        layer : str, optional
            指定层级 ("trend"/"decision"/"execution")，None 检查全部

        Returns
        -------
        bool
            是否所有指定层级都已初始化 (有足够的 bar 数据)
        """
        if not self.enabled:
            return False

        min_bars = {
            'trend': 200,      # SMA_200 需要 200 根
            'decision': 50,    # SMA_50 需要 50 根
            'execution': 20,   # RSI_14 + EMA_10 需要 ~20 根
        }

        managers = {
            'trend': self.trend_manager,
            'decision': self.decision_manager,
            'execution': self.execution_manager,
        }

        if layer:
            if layer not in managers:
                return False
            mgr = managers[layer]
            bars_count = len(mgr.recent_bars) if hasattr(mgr, 'recent_bars') else 0
            return bars_count >= min_bars.get(layer, 0)

        # 检查全部
        for name, mgr in managers.items():
            if mgr is None:
                return False
            bars_count = len(mgr.recent_bars) if hasattr(mgr, 'recent_bars') else 0
            if bars_count < min_bars.get(name, 0):
                self.logger.debug(f"{name} 层未初始化: {bars_count}/{min_bars[name]} bars")
                return False

        return True

    def route_bar(self, bar: Bar) -> str:
        """
        路由 bar 到对应的管理器 (精确 BarType 匹配)

        Parameters
        ----------
        bar : Bar
            接收到的 bar 数据

        Returns
        -------
        str
            路由目标: "trend" / "decision" / "execution" / "unknown" / "disabled"
        """
        if not self.enabled:
            return "disabled"

        # 使用精确的 BarType 匹配
        if self.trend_bar_type and bar.bar_type == self.trend_bar_type:
            self.trend_manager.update(bar)
            self._last_trend_price = float(bar.close)
            self.logger.debug(f"[1D] 趋势层 bar 更新: close={bar.close}")
            return "trend"

        elif self.decision_bar_type and bar.bar_type == self.decision_bar_type:
            self.decision_manager.update(bar)
            self._last_decision_price = float(bar.close)
            self.logger.debug(f"[4H] 决策层 bar 更新: close={bar.close}")
            return "decision"

        elif self.execution_bar_type and bar.bar_type == self.execution_bar_type:
            self.execution_manager.update(bar)
            self._last_execution_price = float(bar.close)
            self.logger.debug(f"[15M] 执行层 bar 更新: close={bar.close}")
            return "execution"

        else:
            self.logger.warning(f"Unknown bar type: {bar.bar_type}")
            return "unknown"

    def evaluate_risk_state(self, current_price: float) -> RiskState:
        """
        评估趋势层风险状态 (Risk-On / Risk-Off)

        使用 MACD 替代 ADX (ADX 未在 TechnicalIndicatorManager 实现)

        Parameters
        ----------
        current_price : float
            当前价格

        Returns
        -------
        RiskState
            RISK_ON (可交易) 或 RISK_OFF (观望)
        """
        if not self.trend_manager or not self.trend_manager.is_initialized():
            self.logger.warning("趋势层未初始化，返回 RISK_OFF")
            return RiskState.RISK_OFF

        trend_config = self.config.get('trend_layer', {})
        tech_data = self.trend_manager.get_technical_data(current_price)

        # 规则 1: 价格在 SMA_200 上方
        sma_period = trend_config.get('sma_period', 200)
        sma_value = tech_data.get(f'sma_{sma_period}', current_price)
        price_above_sma = current_price > sma_value

        # 规则 2: MACD > 0 (替代 ADX，判断趋势方向)
        macd_value = tech_data.get('macd', 0)
        macd_positive = macd_value > 0

        # 综合判断
        require_above_sma = trend_config.get('require_above_sma', True)
        require_macd_positive = trend_config.get('require_macd_positive', True)

        conditions_met = True
        if require_above_sma:
            conditions_met = conditions_met and price_above_sma
        if require_macd_positive:
            conditions_met = conditions_met and macd_positive

        if conditions_met:
            self._risk_state = RiskState.RISK_ON
        else:
            self._risk_state = RiskState.RISK_OFF

        self._risk_state_updated = datetime.utcnow()

        self.logger.info(
            f"[1D] 趋势层评估: {self._risk_state.value} "
            f"(price={current_price:.2f}, SMA_{sma_period}={sma_value:.2f}, MACD={macd_value:.2f})"
        )

        return self._risk_state

    def get_risk_state(self) -> RiskState:
        """获取当前风险状态 (带缓存)"""
        return self._risk_state

    def get_decision_state(self) -> DecisionState:
        """获取当前决策状态"""
        return self._decision_state

    def set_decision_state(self, state: DecisionState, confidence: str = "MEDIUM"):
        """设置决策状态 (由 MultiAgentAnalyzer 调用)"""
        old_state = self._decision_state
        self._decision_state = state
        self._decision_confidence = confidence
        self._decision_updated = datetime.utcnow()

        self.logger.info(
            f"[4H] 决策层状态更新: {old_state.value} → {state.value} "
            f"(confidence={confidence})"
        )

    def get_technical_data_for_layer(self, layer: str, current_price: float) -> Dict[str, Any]:
        """
        获取指定层的技术数据

        Parameters
        ----------
        layer : str
            "trend" / "decision" / "execution"
        current_price : float
            当前价格

        Returns
        -------
        Dict
            技术指标数据
        """
        manager = {
            "trend": self.trend_manager,
            "decision": self.decision_manager,
            "execution": self.execution_manager,
        }.get(layer)

        if manager and manager.is_initialized():
            data = manager.get_technical_data(current_price)
            data['_layer'] = layer
            data['_timeframe'] = {
                'trend': '1D',
                'decision': '4H',
                'execution': '15M',
            }.get(layer, 'unknown')
            return data
        return {'_layer': layer, '_initialized': False}

    def check_execution_confirmation(self, current_price: float) -> Dict[str, Any]:
        """
        检查执行层入场确认条件

        Returns
        -------
        Dict
            {
                'confirmed': bool,
                'rsi': float,
                'rsi_in_range': bool,
                'reason': str
            }
        """
        if not self.execution_manager or not self.execution_manager.is_initialized():
            return {
                'confirmed': False,
                'reason': '执行层未初始化'
            }

        exec_config = self.config.get('execution_layer', {})
        tech_data = self.execution_manager.get_technical_data(current_price)

        rsi = tech_data.get('rsi', 50)
        rsi_min = exec_config.get('rsi_entry_min', 35)
        rsi_max = exec_config.get('rsi_entry_max', 65)
        rsi_in_range = rsi_min <= rsi <= rsi_max

        return {
            'confirmed': rsi_in_range,
            'rsi': rsi,
            'rsi_in_range': rsi_in_range,
            'rsi_range': [rsi_min, rsi_max],
            'reason': f'RSI={rsi:.1f} {"在" if rsi_in_range else "不在"}范围[{rsi_min}, {rsi_max}]内'
        }

    def is_all_layers_initialized(self) -> bool:
        """检查所有层是否都已初始化"""
        if not self.enabled:
            return True

        return (
            self.trend_manager and self.trend_manager.is_initialized() and
            self.decision_manager and self.decision_manager.is_initialized() and
            self.execution_manager and self.execution_manager.is_initialized()
        )

    def get_summary(self) -> Dict[str, Any]:
        """获取多时间框架状态摘要"""
        return {
            "enabled": self.enabled,
            "risk_state": self._risk_state.value if self._risk_state else "UNKNOWN",
            "risk_state_updated": self._risk_state_updated.isoformat() if self._risk_state_updated else None,
            "decision_state": self._decision_state.value if self._decision_state else "UNKNOWN",
            "decision_confidence": self._decision_confidence,
            "decision_updated": self._decision_updated.isoformat() if self._decision_updated else None,
            "layers_initialized": {
                "trend": self.trend_manager.is_initialized() if self.trend_manager else False,
                "decision": self.decision_manager.is_initialized() if self.decision_manager else False,
                "execution": self.execution_manager.is_initialized() if self.execution_manager else False,
            },
            "last_prices": {
                "trend": self._last_trend_price,
                "decision": self._last_decision_price,
                "execution": self._last_execution_price,
            }
        }
```

### 3.2 改动: DeepSeekAIStrategyConfig

由于 `frozen=True` 的 dataclass 不支持 `dict` 默认值，使用扁平化字段：

```python
# strategy/deepseek_strategy.py

class DeepSeekAIStrategyConfig(StrategyConfig, frozen=True):
    """Configuration for DeepSeek AI Strategy."""

    # ... 现有字段 ...

    # Multi-Timeframe Configuration (v3.0)
    # 使用基本类型，避免 frozen dataclass 限制
    multi_timeframe_enabled: bool = False

    # 趋势层 (1D)
    mtf_trend_timeframe: str = "1d"
    mtf_trend_sma_period: int = 200
    mtf_trend_require_above_sma: bool = True
    mtf_trend_require_macd_positive: bool = True

    # 决策层 (4H)
    mtf_decision_timeframe: str = "4h"
    mtf_decision_debate_rounds: int = 2

    # 执行层 (15M)
    mtf_execution_timeframe: str = "15m"
    mtf_execution_rsi_entry_min: int = 35
    mtf_execution_rsi_entry_max: int = 65
```

### 3.3 改动: main_live.py

```python
# main_live.py

def get_strategy_config(config_manager: ConfigManager) -> DeepSeekAIStrategyConfig:
    """Build strategy configuration from ConfigManager."""

    # ... 现有代码 ...

    # Multi-Timeframe Configuration (v3.0)
    # 注意: 使用 get() 直接访问，不依赖不存在的辅助方法
    mtf_enabled = config_manager.get('multi_timeframe', 'enabled', default=False)

    config_kwargs = {
        # ... 现有参数 ...

        # Multi-Timeframe
        'multi_timeframe_enabled': mtf_enabled,
    }

    if mtf_enabled:
        # 直接使用 get() 访问嵌套配置
        config_kwargs.update({
            # 趋势层
            'mtf_trend_timeframe': config_manager.get('multi_timeframe', 'trend_layer', 'timeframe', default='1d'),
            'mtf_trend_sma_period': config_manager.get('multi_timeframe', 'trend_layer', 'sma_period', default=200),
            'mtf_trend_require_above_sma': config_manager.get('multi_timeframe', 'trend_layer', 'require_above_sma', default=True),
            'mtf_trend_require_macd_positive': config_manager.get('multi_timeframe', 'trend_layer', 'require_macd_positive', default=True),

            # 决策层
            'mtf_decision_timeframe': config_manager.get('multi_timeframe', 'decision_layer', 'timeframe', default='4h'),
            'mtf_decision_debate_rounds': config_manager.get('multi_timeframe', 'decision_layer', 'debate_rounds', default=2),

            # 执行层
            'mtf_execution_timeframe': config_manager.get('multi_timeframe', 'execution_layer', 'default_timeframe', default='15m'),
            'mtf_execution_rsi_entry_min': config_manager.get('multi_timeframe', 'execution_layer', 'rsi_entry_min', default=35),
            'mtf_execution_rsi_entry_max': config_manager.get('multi_timeframe', 'execution_layer', 'rsi_entry_max', default=65),
        })

        print(f"[CONFIG] Multi-Timeframe enabled: 1D→4H→{config_kwargs['mtf_execution_timeframe']}")

    return DeepSeekAIStrategyConfig(**config_kwargs)
```

### 3.4 改动: DeepSeekAIStrategy

#### 3.4.1 __init__ 修改

```python
def __init__(self, config: DeepSeekAIStrategyConfig):
    super().__init__(config)

    # ... 现有初始化 ...

    # Multi-Timeframe Manager (v3.0)
    self.mtf_enabled = config.multi_timeframe_enabled
    self.mtf_manager = None

    # ⚠️ v3.2.8 新增: 异步请求跟踪 (request_bars 是异步的)
    self._pending_requests: Dict[str, UUID4] = {}  # layer -> request_id
    self._mtf_trend_initialized = False
    self._mtf_decision_initialized = False
    self._mtf_execution_initialized = False

    if self.mtf_enabled:
        # 构建 BarType 对象
        # ⚠️ v3.2.7 修正: BarType.from_str() 格式必须严格遵循 NautilusTrader 规范
        # 格式: {symbol}-{step}-{aggregation}-{price_type}-{aggregation_source}
        # 示例: BTCUSDT-PERP.BINANCE-1-DAY-LAST-EXTERNAL
        #
        # 注意: 使用现有的 instrument_id 保持一致性
        instrument_str = str(config.instrument_id)  # e.g., "BTCUSDT-PERP.BINANCE"

        # 方法1: 使用完整的 from_str (推荐)
        # 格式参考: https://nautilustrader.io/docs/latest/api_reference/model/data.html
        self.trend_bar_type = BarType.from_str(
            f"{instrument_str}-1-DAY-LAST-EXTERNAL"
        )
        self.decision_bar_type = BarType.from_str(
            f"{instrument_str}-4-HOUR-LAST-EXTERNAL"
        )
        self.execution_bar_type = BarType.from_str(
            f"{instrument_str}-15-MINUTE-LAST-EXTERNAL"
        )

        # 方法2: 备选 - 如果 from_str 失败，使用显式构造
        # from nautilus_trader.model.data import BarSpecification, BarAggregation, PriceType
        # from nautilus_trader.model.identifiers import InstrumentId
        #
        # trend_spec = BarSpecification(1, BarAggregation.DAY, PriceType.LAST)
        # self.trend_bar_type = BarType(self.instrument_id, trend_spec, AggregationSource.EXTERNAL)

        self.log.info(f"MTF BarTypes: trend={self.trend_bar_type}, decision={self.decision_bar_type}, exec={self.execution_bar_type}")

        # 构建 MTF 配置字典
        mtf_config = {
            'enabled': True,
            'trend_layer': {
                'timeframe': config.mtf_trend_timeframe,
                'sma_period': config.mtf_trend_sma_period,
                'require_above_sma': config.mtf_trend_require_above_sma,
                'require_macd_positive': config.mtf_trend_require_macd_positive,
            },
            'decision_layer': {
                'timeframe': config.mtf_decision_timeframe,
                'debate_rounds': config.mtf_decision_debate_rounds,
            },
            'execution_layer': {
                'default_timeframe': config.mtf_execution_timeframe,
                'rsi_entry_min': config.mtf_execution_rsi_entry_min,
                'rsi_entry_max': config.mtf_execution_rsi_entry_max,
            }
        }

        from indicators.multi_timeframe_manager import MultiTimeframeManager
        self.mtf_manager = MultiTimeframeManager(
            config=mtf_config,
            trend_bar_type=self.trend_bar_type,
            decision_bar_type=self.decision_bar_type,
            execution_bar_type=self.execution_bar_type,
            logger=self.log,
        )

        self.log.info(f"Multi-Timeframe enabled: 1D/4H/15M")
```

#### 3.4.2 on_start 修改

```python
def on_start(self):
    """Actions to be performed on strategy start."""
    # ... 现有代码 ...

    if self.mtf_enabled:
        # 订阅多个时间框架
        self.subscribe_bars(self.trend_bar_type)
        self.subscribe_bars(self.decision_bar_type)
        self.subscribe_bars(self.execution_bar_type)
        self.log.info(f"MTF: Subscribed to 1D, 4H, 15M bars")

        # 预取各层历史数据
        self._prefetch_multi_timeframe_bars()
    else:
        # 现有单时间框架逻辑
        self.subscribe_bars(self.bar_type)

def _prefetch_multi_timeframe_bars(self):
    """
    ⚠️ v3.2.8 修正: 预取各层历史数据，填充指标计算所需的 bar

    NautilusTrader API 签名 (v1.221.0+):
    ```
    request_bars(
        bar_type: BarType,
        start: datetime,        # 必需: 起始时间
        end: datetime = None,   # 可选: 结束时间 (默认当前)
        limit: int = 0,         # 可选: 数量限制
        client_id: ClientId = None,
        callback: Callable = None,  # 可选: 异步回调
    ) -> UUID4
    ```

    ⚠️ 重要: request_bars 是异步的！
    - 返回 UUID4 请求 ID，不直接返回 bars
    - bars 通过 on_historical_data() 回调传递
    - 需要在 on_historical_data() 中处理数据

    预取数量说明:
    - 趋势层 (1D): 需要 220+ 根用于 SMA_200
    - 决策层 (4H): 需要 60+ 根用于 SMA_50, MACD
    - 执行层 (15M): 需要 40+ 根用于 RSI, EMA
    """
    if not self.mtf_enabled:
        return

    self.log.info("MTF: 开始预取历史数据 (异步)...")
    from datetime import datetime, timedelta, timezone

    now = datetime.now(timezone.utc)

    try:
        # === 趋势层 (1D) - SMA_200 需要至少 200 根 ===
        # 220 天前开始，limit=220
        trend_start = now - timedelta(days=220)
        self.log.debug(f"MTF: 预取 1D bars (start={trend_start.date()}, limit=220)...")
        self._pending_requests['trend'] = self.request_bars(
            bar_type=self.trend_bar_type,
            start=trend_start,
            end=None,  # 到当前
            limit=220,
        )

        # === 决策层 (4H) - SMA_50, MACD 需要约 50 根 ===
        # 60 * 4 = 240 小时 = 10 天
        decision_start = now - timedelta(hours=60 * 4)
        self.log.debug(f"MTF: 预取 4H bars (start={decision_start}, limit=60)...")
        self._pending_requests['decision'] = self.request_bars(
            bar_type=self.decision_bar_type,
            start=decision_start,
            end=None,
            limit=60,
        )

        # === 执行层 (15M) - RSI, EMA 需要约 30 根 ===
        # 40 * 15 = 600 分钟 = 10 小时
        execution_start = now - timedelta(minutes=40 * 15)
        self.log.debug(f"MTF: 预取 15M bars (start={execution_start}, limit=40)...")
        self._pending_requests['execution'] = self.request_bars(
            bar_type=self.execution_bar_type,
            start=execution_start,
            end=None,
            limit=40,
        )

        self.log.info("MTF: 历史数据请求已发送，等待 on_historical_data() 回调")

    except Exception as e:
        self.log.error(f"MTF: 预取历史数据请求失败: {e}")
        # 不抛出异常，允许策略继续运行 (降级模式)

def on_historical_data(self, data):
    """
    ⚠️ v3.2.8 新增: 处理 request_bars 的异步回调

    NautilusTrader 在历史数据到达时调用此方法。
    """
    if not hasattr(data, 'bars') or not data.bars:
        return

    bars = data.bars
    bar_type = data.bar_type

    # 根据 bar_type 路由到对应的层
    if self.mtf_enabled and self.mtf_manager:
        if bar_type == self.trend_bar_type:
            for bar in bars:
                self.mtf_manager.trend_manager.update(bar)
            self.log.info(f"MTF: 趋势层预取完成 ({len(bars)} bars)")
            self._mtf_trend_initialized = True

        elif bar_type == self.decision_bar_type:
            for bar in bars:
                self.mtf_manager.decision_manager.update(bar)
            self.log.info(f"MTF: 决策层预取完成 ({len(bars)} bars)")
            self._mtf_decision_initialized = True

        elif bar_type == self.execution_bar_type:
            for bar in bars:
                self.mtf_manager.execution_manager.update(bar)
            self.log.info(f"MTF: 执行层预取完成 ({len(bars)} bars)")
            self._mtf_execution_initialized = True

        # 检查是否所有层都已初始化
        if getattr(self, '_mtf_trend_initialized', False) and \
           getattr(self, '_mtf_decision_initialized', False) and \
           getattr(self, '_mtf_execution_initialized', False):
            self._verify_mtf_initialization()

def _verify_mtf_initialization(self):
    """验证各层指标管理器是否已正确初始化"""
    issues = []

    # 趋势层: 需要至少 200 根 bar 用于 SMA_200
    trend_bars_count = len(self.mtf_manager.trend_manager.recent_bars) if hasattr(self.mtf_manager.trend_manager, 'recent_bars') else 0
    if trend_bars_count < 200:
        issues.append(f"趋势层 bars 不足: {trend_bars_count}/200")

    # 决策层: 需要至少 50 根
    decision_bars_count = len(self.mtf_manager.decision_manager.recent_bars) if hasattr(self.mtf_manager.decision_manager, 'recent_bars') else 0
    if decision_bars_count < 50:
        issues.append(f"决策层 bars 不足: {decision_bars_count}/50")

    # 执行层: 需要至少 20 根
    execution_bars_count = len(self.mtf_manager.execution_manager.recent_bars) if hasattr(self.mtf_manager.execution_manager, 'recent_bars') else 0
    if execution_bars_count < 20:
        issues.append(f"执行层 bars 不足: {execution_bars_count}/20")

    if issues:
        self.log.warning(f"MTF 初始化警告: {', '.join(issues)}")
        if self.telegram_bot and self.enable_telegram:
            self.telegram_bot.send_message_sync(
                f"⚠️ MTF 初始化警告:\n" + "\n".join(f"• {i}" for i in issues)
            )
    else:
        self.log.info("MTF: 所有层指标管理器初始化完成 ✓")
```

#### 3.4.3 on_bar 修改 (精确匹配)

```python
def on_bar(self, bar: Bar):
    """Handle bar updates."""
    self.bars_received += 1

    if self.mtf_enabled and self.mtf_manager:
        # 使用 MTF Manager 的精确路由
        layer = self.mtf_manager.route_bar(bar)

        if layer == "trend":
            # 日线收盘，触发趋势层评估
            self._on_trend_bar_close(bar)
        elif layer == "decision":
            # 4H 收盘，触发决策层分析
            self._on_decision_bar_close(bar)
        elif layer == "execution":
            # 执行层更新
            with self._state_lock:
                self._cached_current_price = float(bar.close)
        elif layer == "unknown":
            self.log.warning(f"Unknown bar type received: {bar.bar_type}")
    else:
        # 现有单时间框架逻辑
        self.indicator_manager.update(bar)
        with self._state_lock:
            self._cached_current_price = float(bar.close)

def _on_trend_bar_close(self, bar: Bar):
    """日线收盘处理"""
    from indicators.multi_timeframe_manager import RiskState

    current_price = float(bar.close)
    risk_state = self.mtf_manager.evaluate_risk_state(current_price)

    self.log.info(f"[1D] 趋势层评估完成: {risk_state.value}")

    if risk_state == RiskState.RISK_OFF:
        if self.telegram_bot and self.enable_telegram:
            self.telegram_bot.send_message_sync(
                f"⚠️ [1D] 趋势层: RISK_OFF\n"
                f"价格: ${current_price:,.2f}\n"
                f"暂停新开仓"
            )

def _on_decision_bar_close(self, bar: Bar):
    """4H 收盘处理 - 触发 Bull/Bear 辩论"""
    self.log.info("[4H] 决策层 bar 收盘，将在下次定时器触发分析")
```

#### 3.4.4 on_timer 修改

```python
def on_timer(self, event):
    """Periodic analysis and trading logic."""
    if not self.mtf_enabled:
        return self._on_timer_single_timeframe(event)

    return self._on_timer_multi_timeframe(event)

def _on_timer_multi_timeframe(self, event):
    """多时间框架定时分析"""
    from indicators.multi_timeframe_manager import RiskState, DecisionState

    self.log.info("=" * 60)
    self.log.info("[MTF] Running Multi-Timeframe Analysis...")

    # Step 1: 检查趋势层状态
    risk_state = self.mtf_manager.get_risk_state()

    if risk_state == RiskState.RISK_OFF:
        self.log.info("[1D] ⚠️ RISK_OFF - 跳过交易分析")
        return

    # Step 2: 获取决策层技术数据
    current_price = self._cached_current_price
    decision_tech_data = self.mtf_manager.get_technical_data_for_layer("decision", current_price)
    decision_tech_data['trend_layer_state'] = risk_state.value

    # Step 3: 运行 MultiAgent 分析 (基于 4H 数据)
    self.log.info("[4H] 开始 Bull/Bear 辩论...")

    multi_agent_result = self.multi_agent.analyze(
        symbol=str(self.instrument_id),
        technical_report=decision_tech_data,
        sentiment_report=self._get_sentiment_data(),
        current_position=self._get_current_position_info(),
        price_data={'price': current_price},
    )

    # Step 4: 更新决策层状态
    signal = multi_agent_result.get('signal', 'HOLD')
    confidence = multi_agent_result.get('confidence', 'LOW')

    if signal == 'BUY':
        self.mtf_manager.set_decision_state(DecisionState.ALLOW_LONG, confidence)
    elif signal == 'SELL':
        self.mtf_manager.set_decision_state(DecisionState.ALLOW_SHORT, confidence)
    else:
        self.mtf_manager.set_decision_state(DecisionState.WAIT, confidence)

    # Step 5: 执行层入场确认
    if signal in ['BUY', 'SELL']:
        confirmation = self.mtf_manager.check_execution_confirmation(current_price)

        if confirmation['confirmed']:
            self.log.info(f"[15M] ✅ 执行层确认: {confirmation['reason']}")
            self._execute_trade(multi_agent_result)
        else:
            self.log.info(f"[15M] ⏳ 执行层等待: {confirmation['reason']}")
    else:
        self.log.info(f"[4H] 决策层信号: {signal} - 不执行交易")
```

---

## 4. 诊断工具适配

### 4.1 diagnose_realtime.py 新增函数

```python
def diagnose_multi_timeframe(config_manager: ConfigManager):
    """诊断多时间框架配置和状态"""
    print("\n" + "=" * 60)
    print("🕐 多时间框架诊断")
    print("=" * 60)

    # 使用 get() 直接访问
    mtf_enabled = config_manager.get('multi_timeframe', 'enabled', default=False)
    print(f"多时间框架启用状态: {'✅ 已启用' if mtf_enabled else '❌ 未启用'}")

    if not mtf_enabled:
        print("跳过多时间框架诊断 (未启用)")
        return

    # 趋势层配置
    print(f"\n📈 趋势层 (1D):")
    print(f"  - 时间框架: {config_manager.get('multi_timeframe', 'trend_layer', 'timeframe', default='1d')}")
    print(f"  - SMA 周期: {config_manager.get('multi_timeframe', 'trend_layer', 'sma_period', default=200)}")
    print(f"  - 要求价格在 SMA 上方: {config_manager.get('multi_timeframe', 'trend_layer', 'require_above_sma', default=True)}")
    print(f"  - 要求 MACD > 0: {config_manager.get('multi_timeframe', 'trend_layer', 'require_macd_positive', default=True)}")

    # 决策层配置
    print(f"\n📊 决策层 (4H):")
    print(f"  - 时间框架: {config_manager.get('multi_timeframe', 'decision_layer', 'timeframe', default='4h')}")
    print(f"  - 辩论轮数: {config_manager.get('multi_timeframe', 'decision_layer', 'debate_rounds', default=2)}")

    # 执行层配置
    print(f"\n⚡ 执行层 (15M):")
    print(f"  - 默认周期: {config_manager.get('multi_timeframe', 'execution_layer', 'default_timeframe', default='15m')}")
    rsi_min = config_manager.get('multi_timeframe', 'execution_layer', 'rsi_entry_min', default=35)
    rsi_max = config_manager.get('multi_timeframe', 'execution_layer', 'rsi_entry_max', default=65)
    print(f"  - RSI 入场范围: [{rsi_min}, {rsi_max}]")

    # 实时数据验证
    print("\n📡 实时数据验证:")
    try:
        import requests

        for tf, name in [('1d', '趋势层'), ('4h', '决策层'), ('15m', '执行层')]:
            url = f"https://fapi.binance.com/fapi/v1/klines?symbol=BTCUSDT&interval={tf}&limit=1"
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                data = response.json()[0]
                print(f"  ✅ {name} ({tf.upper()}): close=${float(data[4]):,.2f}")
            else:
                print(f"  ❌ {name} ({tf.upper()}): 获取失败")
    except Exception as e:
        print(f"  ❌ API 调用失败: {e}")
```

---

## 5. 测试用例

### 5.1 tests/test_multi_timeframe.py

**注意**: 当前测试目录没有 `conftest.py`，测试使用手动设置方式。

```python
"""
Multi-Timeframe Manager Tests v3.0

注意: 当前测试框架不使用 pytest fixtures (无 conftest.py)，
使用 unittest 风格的手动设置。
"""
import pytest
from unittest.mock import Mock, MagicMock
from datetime import datetime


class TestMultiTimeframeManager:
    """多时间框架管理器测试"""

    def get_disabled_config(self):
        """获取禁用配置"""
        return {"enabled": False}

    def get_enabled_config(self):
        """获取启用配置"""
        return {
            "enabled": True,
            "trend_layer": {
                "timeframe": "1d",
                "sma_period": 200,
                "require_above_sma": True,
                "require_macd_positive": True,
            },
            "decision_layer": {
                "timeframe": "4h",
                "debate_rounds": 2,
            },
            "execution_layer": {
                "default_timeframe": "15m",
                "rsi_entry_min": 35,
                "rsi_entry_max": 65,
            }
        }

    def test_init_disabled(self):
        """测试禁用状态初始化"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager

        manager = MultiTimeframeManager(self.get_disabled_config())
        assert not manager.enabled
        assert manager.trend_manager is None

    def test_init_enabled(self):
        """测试启用状态初始化"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager

        manager = MultiTimeframeManager(self.get_enabled_config())
        assert manager.enabled
        assert manager.trend_manager is not None
        assert manager.decision_manager is not None
        assert manager.execution_manager is not None

    def test_risk_state_default(self):
        """测试默认风险状态"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager, RiskState

        manager = MultiTimeframeManager(self.get_enabled_config())
        assert manager.get_risk_state() == RiskState.RISK_OFF

    def test_decision_state_default(self):
        """测试默认决策状态"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager, DecisionState

        manager = MultiTimeframeManager(self.get_enabled_config())
        assert manager.get_decision_state() == DecisionState.WAIT

    def test_set_decision_state(self):
        """测试设置决策状态"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager, DecisionState

        manager = MultiTimeframeManager(self.get_enabled_config())
        manager.set_decision_state(DecisionState.ALLOW_LONG, "HIGH")

        assert manager.get_decision_state() == DecisionState.ALLOW_LONG
        assert manager._decision_confidence == "HIGH"

    def test_route_bar_disabled(self):
        """测试禁用时的 bar 路由"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager

        manager = MultiTimeframeManager(self.get_disabled_config())
        mock_bar = Mock()

        result = manager.route_bar(mock_bar)
        assert result == "disabled"

    def test_check_execution_confirmation_in_range(self):
        """测试执行层确认 - RSI 在范围内"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager

        manager = MultiTimeframeManager(self.get_enabled_config())

        # Mock execution_manager
        manager.execution_manager = Mock()
        manager.execution_manager.is_initialized.return_value = True
        manager.execution_manager.get_technical_data.return_value = {'rsi': 50}

        result = manager.check_execution_confirmation(100000)
        assert result['confirmed'] == True
        assert result['rsi'] == 50

    def test_check_execution_confirmation_out_of_range(self):
        """测试执行层确认 - RSI 超出范围"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager

        manager = MultiTimeframeManager(self.get_enabled_config())

        manager.execution_manager = Mock()
        manager.execution_manager.is_initialized.return_value = True
        manager.execution_manager.get_technical_data.return_value = {'rsi': 75}

        result = manager.check_execution_confirmation(100000)
        assert result['confirmed'] == False
        assert result['rsi'] == 75

    def test_get_summary(self):
        """测试获取状态摘要"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager

        manager = MultiTimeframeManager(self.get_enabled_config())
        summary = manager.get_summary()

        assert 'enabled' in summary
        assert 'risk_state' in summary
        assert 'decision_state' in summary
        assert 'layers_initialized' in summary


class TestRiskEvaluation:
    """风险评估测试"""

    def get_config(self):
        return {
            "enabled": True,
            "trend_layer": {
                "sma_period": 200,
                "require_above_sma": True,
                "require_macd_positive": True,
            },
            "decision_layer": {},
            "execution_layer": {},
        }

    def test_risk_on_above_sma_macd_positive(self):
        """测试价格在 SMA 上方且 MACD > 0 时应为 RISK_ON"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager, RiskState

        manager = MultiTimeframeManager(self.get_config())
        manager.trend_manager = Mock()
        manager.trend_manager.is_initialized.return_value = True
        manager.trend_manager.get_technical_data.return_value = {
            'sma_200': 95000,
            'macd': 100,
        }

        result = manager.evaluate_risk_state(100000)
        assert result == RiskState.RISK_ON

    def test_risk_off_below_sma(self):
        """测试价格在 SMA 下方时应为 RISK_OFF"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager, RiskState

        manager = MultiTimeframeManager(self.get_config())
        manager.trend_manager = Mock()
        manager.trend_manager.is_initialized.return_value = True
        manager.trend_manager.get_technical_data.return_value = {
            'sma_200': 105000,
            'macd': 100,
        }

        result = manager.evaluate_risk_state(100000)
        assert result == RiskState.RISK_OFF

    def test_risk_off_macd_negative(self):
        """测试 MACD < 0 时应为 RISK_OFF"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager, RiskState

        manager = MultiTimeframeManager(self.get_config())
        manager.trend_manager = Mock()
        manager.trend_manager.is_initialized.return_value = True
        manager.trend_manager.get_technical_data.return_value = {
            'sma_200': 95000,
            'macd': -50,
        }

        result = manager.evaluate_risk_state(100000)
        assert result == RiskState.RISK_OFF


class TestBackwardCompatibility:
    """向后兼容测试"""

    def test_single_timeframe_mode(self):
        """确保禁用 MTF 时系统行为不变"""
        from indicators.multi_timeframe_manager import MultiTimeframeManager

        config = {"enabled": False}
        manager = MultiTimeframeManager(config)

        assert not manager.enabled
        assert manager.is_all_layers_initialized() == True  # 未启用视为已初始化

        mock_bar = Mock()
        assert manager.route_bar(mock_bar) == "disabled"
```

---

## 6. 实施阶段和优先级

### Phase 1: 基础设施 (优先级: 高)

| 任务 | 文件 | 状态 |
|------|------|------|
| 1.1 添加配置结构 | `configs/base.yaml` | ✅ 已设计 |
| 1.2 创建 MultiTimeframeManager | `indicators/multi_timeframe_manager.py` | ✅ 已设计 |
| 1.3 修改 DeepSeekAIStrategyConfig | `strategy/deepseek_strategy.py` | ✅ 已设计 |

### Phase 2: 策略集成 (优先级: 高)

| 任务 | 文件 | 状态 |
|------|------|------|
| 2.1 修改 main_live.py | `main_live.py` | ✅ 已设计 |
| 2.2 修改 __init__ | `strategy/deepseek_strategy.py` | ✅ 已设计 |
| 2.3 修改 on_start | `strategy/deepseek_strategy.py` | ✅ 已设计 |
| 2.4 修改 on_bar (精确匹配) | `strategy/deepseek_strategy.py` | ✅ 已设计 |
| 2.5 修改 on_timer | `strategy/deepseek_strategy.py` | ✅ 已设计 |

### Phase 3: 诊断和测试 (优先级: 中)

| 任务 | 文件 | 状态 |
|------|------|------|
| 3.1 添加 MTF 诊断函数 | `scripts/diagnose_realtime.py` | ✅ 已设计 |
| 3.2 添加单元测试 | `tests/test_multi_timeframe.py` | ✅ 已设计 |
| 3.3 回归测试验证 | 全部测试文件 | 待实施 |

---

## 7. 审查结论 (合并自 v2.0 审查报告)

### 7.1 已解决的问题

| 原问题 | 解决方案 |
|--------|----------|
| ADX 指标未实现 | 使用 MACD > 0 替代 ADX 判断趋势 |
| on_bar 字符串匹配问题 | 改用 `bar.bar_type == self.xxx_bar_type` 精确匹配 |
| frozen dataclass 不支持 dict | 使用扁平化基本类型字段 |
| ConfigManager 辅助方法不存在 | 直接使用 `get()` 方法访问嵌套配置 |
| SMA_200 未包含在默认周期 | 在 TechnicalIndicatorManager 初始化时指定 |
| 测试无 conftest.py | 使用手动设置方式编写测试 |

### 7.2 剩余风险

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 多 bar 订阅内存增加 | 系统稳定性 | 限制历史 bar 数量 |
| 时间框架同步问题 | 信号准确性 | 使用 UTC 时间，添加日志 |
| AI 调用次数增加 | 成本和延迟 | 缓存决策结果 |

### 7.3 回滚计划

1. **立即回滚**: 设置 `multi_timeframe.enabled: false`
2. **代码回滚**: `git revert` 到稳定版本
3. **服务恢复**: 重启服务，验证单时间框架模式正常

---

## 8. 附录

### 8.1 参考资料

- [TradingAgents GitHub](https://github.com/TauricResearch/TradingAgents)
- [NautilusTrader 文档](https://nautilustrader.io/docs/)
- [CLAUDE.md 项目规范](/home/user/AItrader/CLAUDE.md)

### 8.2 文件清理记录

v3.0 删除了以下冗余文件 (内容已合并到本文档):

- `docs/MULTI_TIMEFRAME_REVIEW_REPORT.md` - 审查结论已合并到第 7 节

---

## 9. 订单流数据整合 (v3.2 新增)

本节描述如何利用 Binance K线完整数据 + Coinalyze API 增强交易信号质量。

### 9.1 数据源概览

#### 9.1.1 成本对比

| 数据源 | 价格 | 数据内容 | 认证要求 |
|--------|------|----------|----------|
| **Binance API** | 免费 | K线12列、多空比、大户持仓 | 无需 API Key |
| **Coinalyze API** | 免费 (需注册) | 聚合OI、清算、资金费率 | **需要 API Key** |
| CoinGlass | $29-699/月 | 专业衍生品数据 | 付费 API Key |
| CryptoQuant | $39-799/月 | 链上+衍生品数据 | 付费 API Key |

**结论**: Binance (完全免费) + Coinalyze (免费注册获取 API Key) 组合成本为 $0。

#### 9.1.2 Binance 免费数据

| 端点 | 数据 | 用途 |
|------|------|------|
| `/fapi/v1/klines` | K线12列 (含 taker_buy) | 计算买卖比 |
| `/futures/data/globalLongShortAccountRatio` | 多空账户比 | 市场情绪 |
| `/futures/data/topLongShortPositionRatio` | 大户持仓比 | 主力动向 |
| `/futures/data/takerlongshortRatio` | 主动买卖比 | 资金流向 |

#### 9.1.3 Coinalyze API (需 API Key)

**重要**: Coinalyze API 需要注册并获取免费 API Key。

**获取 API Key**:
1. 访问 [coinalyze.net](https://coinalyze.net/) 注册账户
2. 在账户设置中生成 API Key
3. 将 API Key 添加到 `~/.env.aitrader`: `COINALYZE_API_KEY=xxx`

**API 规格**:
| 项目 | 值 |
|------|-----|
| Base URL | `https://api.coinalyze.net/v1` |
| 认证方式 | Header: `api_key` 或 Query: `?api_key=xxx` |
| 速率限制 | **40 次/分钟** |
| 超限响应 | HTTP 429 + `Retry-After` header |
| 数据保留 | 日内数据保留 1500-2000 条 |

**Symbol 格式** (重要):
```
格式: [PAIR]_[CONTRACT_TYPE].[EXCHANGE_CODE]
示例: BTCUSDT_PERP.A

交易所代码:
- A = Binance
- 其他代码通过 /v1/exchanges 获取
```

**可用端点**:

| 端点 | 数据 | 用途 | 示例 Symbol |
|------|------|------|-------------|
| `/v1/open-interest` | 当前聚合 OI | 趋势强度 | `BTCUSDT_PERP.A` |
| `/v1/open-interest-history` | OI 历史 | OI 变化趋势 | `BTCUSDT_PERP.A` |
| `/v1/funding-rate` | 当前资金费率 | 情绪指标 | `BTCUSDT_PERP.A` |
| `/v1/funding-rate-history` | 费率历史 | 费率趋势 | `BTCUSDT_PERP.A` |
| `/v1/liquidation-history` | 清算历史 | 极端行情信号 | `BTCUSDT_PERP.A` |
| `/v1/long-short-ratio-history` | 多空比历史 | 市场偏向 | `BTCUSDT_PERP.A` |
| `/v1/exchanges` | 交易所列表 | 获取交易所代码 | - |
| `/v1/future-markets` | 市场列表 | 支持的交易对 | - |

**响应示例** (Open Interest):
```json
[
  {
    "symbol": "BTCUSDT_PERP.A",
    "openInterest": 185000000000,  // 单位: 合约面值
    "openInterestUsd": 18500000000, // 单位: USD
    "timestamp": 1706270400000
  }
]
```

**降级策略**: 如果 Coinalyze API 不可用，系统将:
1. 使用默认值 (OI=0, 清算=0, 费率=0)
2. 记录警告日志
3. 继续正常交易 (仅依赖 Binance 数据)

**Python 包** (可选):
```bash
pip install coinalyze  # 非官方 Python 包装器
```

### 9.2 Binance K线完整字段

#### 9.2.1 K线 12 列详解

```
列索引  列名               类型     当前使用  本方案使用
------  ----               ----     --------  ----------
[0]     open_time          int      ✓         ✓
[1]     open               float    ✓         ✓
[2]     high               float    ✓         ✓
[3]     low                float    ✓         ✓
[4]     close              float    ✓         ✓
[5]     volume             float    ✓         ✓ (用于计算 buy_ratio)
[6]     close_time         int      ✗         ✗
[7]     quote_volume       float    ✗         ✓ (USDT 成交额)
[8]     trades_count       int      ✗         ✓ (成交笔数)
[9]     taker_buy_volume   float    ✗         ✓ (主动买入量) ⭐ 核心
[10]    taker_buy_quote    float    ✗         ✓ (主动买入额)
[11]    ignore             -        ✗         ✗
```

#### 9.2.2 关键指标计算

```python
# 只做简单除法，不要自己计算复杂指标！

# 买卖比 (核心指标)
buy_ratio = taker_buy_volume / volume  # 范围 0-1, >0.5 多头主导

# 平均单笔成交额 (判断大户活动)
avg_trade_usdt = quote_volume / trades_count

# 让 AI 分析的数据:
# - buy_ratio 序列 → AI 判断趋势、背离
# - 不要自己计算 CVD，让 AI 从 buy_ratio 序列中分析
```

### 9.3 数据处理原则

#### 9.3.1 为什么不自己计算 CVD?

| 自己计算 | 让 AI 分析 |
|----------|------------|
| ❌ 容易出错 (符号、累加) | ✓ AI 擅长模式识别 |
| ❌ 需要维护状态 | ✓ 无状态，每次独立分析 |
| ❌ 背离检测复杂 | ✓ AI 可描述背离特征 |
| ❌ 增加代码复杂度 | ✓ 只传原始数据 |

#### 9.3.2 处理原则

1. **只做简单计算**: 除法 (buy_ratio, avg_trade)
2. **传递原始序列**: 让 AI 看到 10 根 bar 的 buy_ratio 变化
3. **AI 分析复杂模式**: 趋势判断、背离检测、异常识别
4. **结构化输出**: JSON 格式便于程序解析

### 9.4 AI 输入数据结构

#### 9.4.1 完整数据结构

```python
ai_input_data = {
    # === 价格数据 ===
    "price": {
        "current": 100250.5,
        "change_24h_pct": 1.78,
        "high_24h": 101500,
        "low_24h": 98200,
    },

    # === 技术指标 (现有) ===
    "technical": {
        "rsi_14": 58.5,
        "macd": {"value": 125, "signal": 98, "histogram": 27},
        "sma_20": 99800,
        "sma_50": 98500,
        "bb": {"upper": 102000, "middle": 99500, "lower": 97000},
    },

    # === 订单流数据 (v3.2 新增) ⭐ ===
    "order_flow": {
        "current_bar": {
            "buy_ratio": 0.548,       # 主动买入占比
            "volume_usdt": 125312500, # USDT 成交额
            "trades_count": 35680,    # 成交笔数
            "avg_trade_usdt": 3513,   # 平均单笔
        },
        "recent_10_bars": [           # 最近 10 根 bar (让 AI 分析趋势)
            {"close": 99500, "buy_ratio": 0.46, "volume_usdt": 85000000},
            {"close": 99800, "buy_ratio": 0.51, "volume_usdt": 92000000},
            {"close": 100100, "buy_ratio": 0.54, "volume_usdt": 110000000},
            # ... 共 10 条
        ],
        "summary": {
            "avg_buy_ratio_10": 0.532,
            "buy_ratio_trend": "上升",  # 简单判断: 后5根均值 vs 前5根
            "volume_trend": "放量",     # 后5根 vs 前5根
        },
    },

    # === 衍生品数据 (Coinalyze) ===
    "derivatives": {
        "open_interest": {
            "total_usd": 18500000000,  # $185 亿
            "change_24h_pct": 3.5,
        },
        "liquidations_1h": {
            "long_usd": 2500000,   # 多头清算 $250 万
            "short_usd": 1800000,  # 空头清算 $180 万
        },
        "funding_rate": {
            "current": 0.0008,     # 0.08% (正 = 多头付费)
            "avg_8h": 0.0006,
        },
    },

    # === 情绪数据 (Binance) ===
    "sentiment": {
        "long_short_ratio": 1.25,      # >1 多头多
        "top_trader_long_ratio": 0.58, # 大户 58% 做多
    },

    # === 当前持仓 ===
    "current_position": {
        "side": "NONE",  # LONG / SHORT / NONE
        "size_usdt": 0,
        "unrealized_pnl_pct": 0,
    },
}
```

### 9.5 DeepSeek Prompt 设计

#### 9.5.1 优化版 Prompt (~600 tokens)

```
# BTC/USDT 交易分析

## 市场数据
价格: ${price.current} (${price.change_24h_pct}% 24h) | RSI: ${technical.rsi_14} | MACD: ${macd_status}

## 订单流 ⭐
- 买卖比: ${order_flow.current_bar.buy_ratio * 100}% (10根均值: ${order_flow.summary.avg_buy_ratio_10 * 100}%, 趋势${order_flow.summary.buy_ratio_trend})
- 平均单笔: $${order_flow.current_bar.avg_trade_usdt} | 成交额: $${format_millions(order_flow.current_bar.volume_usdt)}

买卖比序列: ${format_buy_ratio_series(order_flow.recent_10_bars)}

## 衍生品
- OI: $${format_billions(derivatives.open_interest.total_usd)} (${derivatives.open_interest.change_24h_pct}% 24h)
- 清算: 多$${format_millions(derivatives.liquidations_1h.long_usd)}/空$${format_millions(derivatives.liquidations_1h.short_usd)}
- 费率: ${derivatives.funding_rate.current * 100}%

## 情绪
多空比: ${sentiment.long_short_ratio} | 大户做多: ${sentiment.top_trader_long_ratio * 100}%

## 当前持仓
${position_status}

---

**分析权重**: 订单流(30%) + 技术面(25%) + 衍生品(25%) + 情绪(20%)

**订单流解读指南**:
- 买卖比 >55% 且上升 → 多头主导
- 买卖比 <45% 且下降 → 空头主导
- 价格涨但买卖比降 → 潜在顶部背离
- 价格跌但买卖比升 → 潜在底部背离
- OI涨+价格涨 → 新多入场 (趋势延续)
- OI涨+价格跌 → 新空入场 (趋势延续)
- OI跌+价格涨 → 空头平仓 (反弹可能结束)
- OI跌+价格跌 → 多头平仓 (下跌可能结束)

请分析并返回 JSON:
```json
{
  "signal": "BUY|SELL|HOLD",
  "confidence": "HIGH|MEDIUM|LOW",
  "analysis": "简要分析 (50字内)",
  "key_signal": "最关键的信号来源",
  "risk_warning": "主要风险",
  "sl_pct": 0.02,
  "tp_pct": 0.03
}
```
```

#### 9.5.2 Prompt 设计原则

1. **结构清晰**: 分块展示，易于 AI 理解
2. **关键标记**: ⭐ 标记核心数据 (订单流)
3. **解读指南**: 内置订单流分析规则，提升准确性
4. **权重分配**: 明确各数据的权重占比
5. **JSON 输出**: 便于程序解析，减少后处理

### 9.6 代码实现模板

#### 9.6.1 订单流处理器

```python
# utils/order_flow_processor.py

class OrderFlowProcessor:
    """处理 Binance K线数据，提取订单流指标"""

    def __init__(self):
        self.buy_ratio_history = []

    def process_klines(self, klines: list) -> dict:
        """
        处理 K线数据，只做简单计算

        Args:
            klines: Binance K线数据列表，每条包含 12 列

        Returns:
            订单流数据字典
        """
        results = []
        for kline in klines[-10:]:  # 只处理最近 10 根
            volume = float(kline[5])
            taker_buy = float(kline[9])
            quote_volume = float(kline[7])
            trades = int(kline[8])

            # 只做简单除法！
            buy_ratio = taker_buy / volume if volume > 0 else 0.5
            avg_trade = quote_volume / trades if trades > 0 else 0

            results.append({
                'close': float(kline[4]),
                'buy_ratio': round(buy_ratio, 4),
                'avg_trade_usdt': round(avg_trade, 2),
                'volume_usdt': round(quote_volume, 0),
                'trades_count': trades,
            })

        self.buy_ratio_history = [r['buy_ratio'] for r in results]

        # 简单趋势判断
        first_half = sum(self.buy_ratio_history[:5]) / 5
        second_half = sum(self.buy_ratio_history[5:]) / 5
        trend = "上升" if second_half > first_half + 0.01 else (
            "下降" if second_half < first_half - 0.01 else "震荡"
        )

        return {
            'current_bar': results[-1],
            'recent_10_bars': results,
            'summary': {
                'avg_buy_ratio_10': round(sum(self.buy_ratio_history) / len(self.buy_ratio_history), 4),
                'buy_ratio_trend': trend,
            }
        }
```

#### 9.6.2 Coinalyze 客户端

```python
# utils/coinalyze_client.py

import aiohttp
from typing import Optional

class CoinalyzeClient:
    """
    Coinalyze API 客户端

    注意: 需要 API Key，从 ~/.env.aitrader 的 COINALYZE_API_KEY 获取
    Symbol 格式: BTCUSDT_PERP.A (A = Binance)
    速率限制: 40 次/分钟
    """

    BASE_URL = "https://api.coinalyze.net/v1"

    # Binance 的 Symbol 格式
    DEFAULT_SYMBOL = "BTCUSDT_PERP.A"

    def __init__(self, api_key: str = "", timeout: int = 10):
        """
        初始化 Coinalyze 客户端

        Args:
            api_key: Coinalyze API Key (从 COINALYZE_API_KEY 环境变量获取)
            timeout: 请求超时时间 (秒)
        """
        self.api_key = api_key
        self.timeout = timeout
        self._enabled = bool(api_key)

        if not self._enabled:
            print("⚠️ CoinalyzeClient: API key not provided, derivatives data disabled")

    def _get_headers(self) -> dict:
        """获取请求头 (含 API Key)"""
        return {"api_key": self.api_key} if self.api_key else {}

    async def get_open_interest(self, symbol: str = None) -> Optional[dict]:
        """
        获取聚合持仓量

        ⚠️ v3.2.6 实际 API 响应格式 (服务器实测):
        Returns:
            {
                "symbol": "BTCUSDT_PERP.A",
                "value": 102726.971,       # ⚠️ BTC 数量，不是 USD!
                "update": 1769420176882    # ⚠️ 毫秒 (13位)!
            }

        注意:
        - value 是 BTC 数量，需要乘以当前价格才能得到 USD 值
        - update 是毫秒时间戳 (与历史端点不同!)
        """
        if not self._enabled:
            return None

        symbol = symbol or self.DEFAULT_SYMBOL
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.BASE_URL}/open-interest"
                params = {"symbols": symbol}
                headers = self._get_headers()
                async with session.get(url, params=params, headers=headers,
                                       timeout=self.timeout) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        return data[0] if data else None
                    elif resp.status == 429:
                        retry_after = resp.headers.get('Retry-After', '60')
                        print(f"⚠️ Coinalyze rate limit, retry after {retry_after}s")
                    else:
                        print(f"⚠️ Coinalyze OI error: HTTP {resp.status}")
        except Exception as e:
            print(f"⚠️ Coinalyze OI error: {e}")
        return None

    async def get_liquidations(self, symbol: str = None) -> Optional[dict]:
        """
        获取清算数据 (历史数据，最近1小时)

        ⚠️ v3.2.6 实际 API 响应格式 (服务器实测):
        原始响应 (嵌套结构):
            [{
                "symbol": "BTCUSDT_PERP.A",
                "history": [
                    {"t": 1769418000, "l": 0.832, "s": 0}
                ]
            }]

        Returns:
            提取后的最新一条:
            {
                "t": 1769418000,  # ⚠️ UNIX 秒 (10位)
                "l": 0.832,       # 多头清算
                "s": 0            # 空头清算
            }

        注意:
        - ⚠️ 响应是嵌套结构，需要从 history 数组提取
        - Binance 从 2021-04 起只提供每秒1条清算数据
        - interval 必须是 "1hour" 不是 "1h"
        - from/to 参数是 UNIX 秒
        """
        if not self._enabled:
            return None

        symbol = symbol or self.DEFAULT_SYMBOL
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.BASE_URL}/liquidation-history"
                # 获取最近1小时的清算数据
                import time
                # ⚠️ 重要: from/to 参数使用 UNIX 秒
                end_time = int(time.time())           # 秒
                start_time = end_time - 3600          # 1小时前 (3600秒)
                params = {
                    "symbols": symbol,
                    "interval": "1hour",  # ⚠️ 必须是 "1hour" 不是 "1h"
                    "from": start_time,   # UNIX 秒
                    "to": end_time        # UNIX 秒
                }
                headers = self._get_headers()
                async with session.get(url, params=params, headers=headers,
                                       timeout=self.timeout) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        # ⚠️ v3.2.6: 处理嵌套结构
                        if data and len(data) > 0:
                            symbol_data = data[0]
                            history = symbol_data.get('history', [])
                            if history and len(history) > 0:
                                # 返回最新一条
                                return history[-1]
                    elif resp.status == 429:
                        print(f"⚠️ Coinalyze rate limit reached")
        except Exception as e:
            print(f"⚠️ Coinalyze liquidation error: {e}")
        return None

    async def get_funding_rate(self, symbol: str = None) -> Optional[dict]:
        """
        获取当前资金费率

        ⚠️ v3.2.6 实际 API 响应格式 (服务器实测):
        Returns:
            {
                "symbol": "BTCUSDT_PERP.A",
                "value": 0.002847,       # 0.2847%
                "update": 1769420174380  # ⚠️ 毫秒 (13位)!
            }

        注意:
        - API 不提供 predictedFundingRate，代码中设为 0
        - update 是毫秒时间戳 (与历史端点不同!)
        """
        if not self._enabled:
            return None

        symbol = symbol or self.DEFAULT_SYMBOL
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.BASE_URL}/funding-rate"
                params = {"symbols": symbol}
                headers = self._get_headers()
                async with session.get(url, params=params, headers=headers,
                                       timeout=self.timeout) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        return data[0] if data else None
                    elif resp.status == 429:
                        print(f"⚠️ Coinalyze rate limit reached")
        except Exception as e:
            print(f"⚠️ Coinalyze funding error: {e}")
        return None

    def is_enabled(self) -> bool:
        """检查客户端是否启用 (有 API Key)"""
        return self._enabled
```

#### 9.6.3 数据组装器 (含格式转换)

```python
# utils/ai_data_assembler.py

class AIDataAssembler:
    """
    组装 AI 输入数据

    负责:
    1. 并行获取外部数据
    2. **格式转换**: 将 Coinalyze 原始格式转换为统一格式
    3. 组装最终数据结构
    """

    def __init__(self, order_flow_processor, coinalyze_client, sentiment_client):
        self.order_flow = order_flow_processor
        self.coinalyze = coinalyze_client
        self.sentiment = sentiment_client
        # 缓存上一次 OI 值用于计算变化率
        self._last_oi_usd: float = 0.0
        self._last_oi_timestamp: int = 0

    # ========================================
    # ⚠️ v3.2.7 新增: 时间戳标准化函数
    # ========================================
    @staticmethod
    def _normalize_timestamp(ts: int, source: str) -> int:
        """
        标准化时间戳为毫秒格式

        ⚠️ Coinalyze API 时间戳单位不一致:
        - 当前端点 (`update`): 毫秒 (13位)
        - 历史端点 (`t`): 秒 (10位)
        - 历史参数 (`from`/`to`): 秒 (10位)

        Args:
            ts: 原始时间戳
            source: 数据来源
                - 'coinalyze_current': 当前端点 (已是毫秒)
                - 'coinalyze_history': 历史端点 (秒→毫秒)
                - 'binance': Binance K线 (已是毫秒)

        Returns:
            标准化为毫秒的时间戳 (13位)

        Examples:
            >>> _normalize_timestamp(1769420176882, 'coinalyze_current')
            1769420176882  # 不变，已是毫秒

            >>> _normalize_timestamp(1769418000, 'coinalyze_history')
            1769418000000  # 秒 → 毫秒
        """
        if ts is None or ts == 0:
            return 0

        # 判断时间戳单位 (10位=秒, 13位=毫秒)
        if source == 'coinalyze_history':
            # 历史端点始终是秒
            return ts * 1000 if ts < 10_000_000_000 else ts
        elif source == 'coinalyze_current':
            # 当前端点始终是毫秒
            return ts
        elif source == 'binance':
            # Binance 始终是毫秒
            return ts
        else:
            # 自动检测: 10位视为秒, 13位视为毫秒
            return ts * 1000 if ts < 10_000_000_000 else ts

    @staticmethod
    def _validate_data(oi_usd: float, current_price: float, liq_data: dict = None) -> dict:
        """
        ⚠️ v3.2.7 新增: 数据合理性验证

        Returns:
            {
                'valid': bool,
                'warnings': List[str]
            }
        """
        warnings = []

        # OI 检查
        if oi_usd is not None:
            if oi_usd < 0:
                warnings.append(f"OI 为负值: {oi_usd}")
            if oi_usd > 1e12:  # 超过 1 万亿 USD
                warnings.append(f"OI 异常高: {oi_usd:.2e}")

        # 价格检查
        if current_price <= 0:
            warnings.append(f"价格无效: {current_price}")
        elif current_price < 100 or current_price > 1_000_000:
            warnings.append(f"价格可能异常: {current_price}")

        # 清算数据检查
        if liq_data:
            long_usd = liq_data.get('long_usd', 0)
            short_usd = liq_data.get('short_usd', 0)
            if long_usd < 0 or short_usd < 0:
                warnings.append(f"清算数据为负: L={long_usd}, S={short_usd}")

        return {
            'valid': len(warnings) == 0,
            'warnings': warnings
        }

    async def assemble(self, klines: list, technical: dict, position: dict) -> dict:
        """
        组装完整的 AI 输入数据

        Args:
            klines: Binance K线数据
            technical: 技术指标数据 (来自 TechnicalIndicatorManager)
            position: 当前持仓信息

        Returns:
            完整的 AI 输入数据字典 (统一格式)
        """
        # 并行获取外部数据
        import asyncio
        oi_task = self.coinalyze.get_open_interest()
        liq_task = self.coinalyze.get_liquidations()
        funding_task = self.coinalyze.get_funding_rate()
        sentiment_task = self.sentiment.get_long_short_ratio()

        oi_raw, liq_raw, funding_raw, sentiment = await asyncio.gather(
            oi_task, liq_task, funding_task, sentiment_task,
            return_exceptions=True
        )

        # 处理订单流
        order_flow_data = self.order_flow.process_klines(klines)

        # 获取当前价格 (用于 OI BTC→USD 转换)
        current_price = float(klines[-1][4]) if klines else 0

        # ⭐ 格式转换: Coinalyze → 统一格式
        derivatives = self._convert_derivatives(oi_raw, liq_raw, funding_raw, current_price)

        # 组装数据
        return {
            "price": {
                "current": float(klines[-1][4]),
                "change_24h_pct": self._calc_change(klines),
            },
            "technical": technical,
            "order_flow": order_flow_data,
            "derivatives": derivatives,
            "sentiment": sentiment if not isinstance(sentiment, Exception) else {},
            "current_position": position,
        }

    def _convert_derivatives(self, oi_raw, liq_raw, funding_raw, current_price: float = 0) -> dict:
        """
        ⭐ 格式转换: Coinalyze API → 统一格式

        Args:
            oi_raw: Open Interest API 响应
            liq_raw: Liquidation API 响应
            funding_raw: Funding Rate API 响应
            current_price: 当前 BTC 价格 (用于 OI BTC→USD 转换)

        ===== 实际 API 响应格式 (2026-01-26 验证) =====

        Open Interest:
        [{"symbol":"BTCUSDT_PERP.A","value":102199.59,"update":1769417410150}]
        - value: OI 值 (BTC 数量，非 USD!)
        - update: 时间戳 (毫秒)

        Funding Rate:
        [{"symbol":"BTCUSDT_PERP.A","value":0.002847,"update":1769417407648}]
        - value: 资金费率 (0.002847 = 0.2847%)
        - update: 时间戳 (毫秒)

        Liquidation History:
        [{"t":1769410800000,"l":123456.78,"s":98765.43}]
        - t: 时间戳
        - l: 多头清算 (USD)
        - s: 空头清算 (USD)

        ===== 统一输出格式 =====
        - open_interest: {"total_usd": 18500000000, "change_24h_pct": 3.5}
        - funding_rate: {"current": 0.0008, "predicted": 0}
        - liquidations_1h: {"long_usd": 2500000, "short_usd": 1800000}
        """
        result = {
            "open_interest": None,
            "liquidations_1h": None,
            "funding_rate": None,
        }

        # === Open Interest 转换 ===
        # ⚠️ 重要: Coinalyze 返回的是 BTC 数量，需要乘以当前价格转 USD
        if oi_raw and not isinstance(oi_raw, Exception):
            try:
                # API 返回数组，取第一个元素
                item = oi_raw[0] if isinstance(oi_raw, list) else oi_raw
                oi_btc = float(item.get('value', 0))  # ⚠️ 这是 BTC 数量!

                # ⚠️ v3.2.7: 标准化时间戳 (当前端点是毫秒)
                oi_timestamp = self._normalize_timestamp(
                    item.get('update', 0), 'coinalyze_current'
                )

                # BTC → USD 转换 (含验证)
                if current_price > 0:
                    oi_usd = oi_btc * current_price
                else:
                    oi_usd = 0
                    print("⚠️ OI 转换警告: current_price 为 0")

                # 计算变化率 (使用缓存值)
                # ⚠️ v3.2.7: 首次运行时返回 None 而非 0
                change_pct = None
                if self._last_oi_usd > 0 and oi_usd > 0:
                    change_pct = round((oi_usd - self._last_oi_usd) / self._last_oi_usd * 100, 2)

                    # 异常变化检测 (> 50%)
                    if abs(change_pct) > 50:
                        print(f"⚠️ OI 异常变化: {change_pct}%")

                self._last_oi_usd = oi_usd
                self._last_oi_timestamp = oi_timestamp

                result["open_interest"] = {
                    "total_usd": oi_usd,           # 已转换为 USD
                    "total_btc": oi_btc,           # v3.2.7: 保留原始 BTC 值
                    "change_24h_pct": change_pct,  # v3.2.7: 首次为 None
                    "timestamp_ms": oi_timestamp,  # v3.2.7: 标准化时间戳
                }
            except (KeyError, TypeError, ValueError) as e:
                print(f"⚠️ OI parse error: {e}")

        # === Funding Rate 转换 ===
        if funding_raw and not isinstance(funding_raw, Exception):
            try:
                item = funding_raw[0] if isinstance(funding_raw, list) else funding_raw

                # ⚠️ v3.2.7: 标准化时间戳 (当前端点是毫秒)
                funding_timestamp = self._normalize_timestamp(
                    item.get('update', 0), 'coinalyze_current'
                )

                result["funding_rate"] = {
                    "current": float(item.get('value', 0)),  # ⚠️ 实际字段是 'value'
                    "predicted": 0,  # Coinalyze 当前端点不返回预测值
                    "timestamp_ms": funding_timestamp,       # v3.2.7: 标准化时间戳
                }
            except (KeyError, TypeError, ValueError) as e:
                print(f"⚠️ Funding parse error: {e}")

        # === Liquidation 转换 ===
        # ⚠️ v3.2.6 修正: 实际响应是嵌套结构
        # [{"symbol": "...", "history": [{"t": ..., "l": ..., "s": ...}]}]
        if liq_raw and not isinstance(liq_raw, Exception):
            try:
                # 提取嵌套的 history 数组
                if isinstance(liq_raw, list) and len(liq_raw) > 0:
                    symbol_data = liq_raw[0]
                    history = symbol_data.get('history', [])
                    if history and len(history) > 0:
                        # 取最新一条 (最后一个)
                        item = history[-1]

                        # ⚠️ v3.2.7: 标准化时间戳 (历史端点是秒)
                        liq_timestamp = self._normalize_timestamp(
                            item.get('t', 0), 'coinalyze_history'
                        )

                        result["liquidations_1h"] = {
                            "long_usd": float(item.get('l', 0)),   # ⚠️ 字段是 'l'
                            "short_usd": float(item.get('s', 0)),  # ⚠️ 字段是 's'
                            "timestamp_ms": liq_timestamp,          # v3.2.7: 标准化时间戳
                        }
            except (KeyError, IndexError, TypeError, ValueError) as e:
                print(f"⚠️ Liquidation parse error: {e}")

        # ⚠️ v3.2.7: 数据验证
        validation = self._validate_data(
            oi_usd=result.get("open_interest", {}).get("total_usd") if result.get("open_interest") else None,
            current_price=current_price,
            liq_data=result.get("liquidations_1h")
        )
        if not validation['valid']:
            for warn in validation['warnings']:
                print(f"⚠️ 数据验证警告: {warn}")

        return result

    def _calc_change(self, klines: list) -> float:
        """计算 24h 涨跌幅"""
        if len(klines) < 2:
            return 0.0
        old_close = float(klines[0][4])
        new_close = float(klines[-1][4])
        return round((new_close - old_close) / old_close * 100, 2) if old_close > 0 else 0.0
```

#### 9.6.4 Coinalyze 数据格式参考 (2026-01-26 服务器实测验证 v3.2.6)

**⚠️ 关键发现汇总 (服务器实测)**:

| 项目 | 之前假设 | 实际值 | 来源 |
|------|---------|--------|------|
| **当前端点时间戳** (`update`) | 秒 | **毫秒** (13位) | 服务器实测 |
| **历史端点时间戳** (`t`) | 秒 | **秒** (10位) | 服务器实测 |
| **历史端点参数** (`from`/`to`) | 秒 | **秒** | 服务器实测 |
| **OI 字段名** | `openInterestUsd` | `value` (BTC 数量) | 服务器实测 |
| **Funding 字段名** | `fundingRate` | `value` | 服务器实测 |
| **Liquidation 响应结构** | 扁平数组 | **嵌套 `history` 数组** | 服务器实测 |
| **OI History 响应** | 单值 | **OHLC 数据** (o,h,l,c) | 服务器实测 |

**⚠️ 时间戳单位不一致 (重要)**:

| 端点类型 | 字段 | 单位 | 示例 |
|---------|------|------|------|
| 当前数据 `/open-interest` | `update` | **毫秒** | `1769420176882` (13位) |
| 当前数据 `/funding-rate` | `update` | **毫秒** | `1769420174380` (13位) |
| 历史参数 `from`/`to` | - | **秒** | `1769416578` (10位) |
| 历史响应 `/liquidation-history` | `t` | **秒** | `1769418000` (10位) |
| 历史响应 `/open-interest-history` | `t` | **秒** | `1769335200` (10位) |

**完整的 interval 参数值**:
```
1min, 5min, 15min, 30min, 1hour, 2hour, 4hour, 6hour, 12hour, daily
```

**API 原始响应 vs 统一格式对照表**:

| 端点 | Coinalyze 原始字段 | 转换后字段 | 说明 |
|------|-------------------|-----------|------|
| `/open-interest` | `value` | `total_usd` | BTC 数量，需乘价格转 USD |
| `/open-interest` | `update` | - | **毫秒** (13位) |
| `/funding-rate` | `value` | `current` | 0.002847 = 0.2847% |
| `/funding-rate` | `update` | - | **毫秒** (13位) |
| `/liquidation-history` | `history[].l` | `long_usd` | ⚠️ 嵌套在 history 内 |
| `/liquidation-history` | `history[].s` | `short_usd` | ⚠️ 嵌套在 history 内 |
| `/liquidation-history` | `history[].t` | - | **秒** (10位) |
| `/open-interest-history` | `history[].c` | - | OI 收盘值 (OHLC) |

**请求参数格式** (history 端点):
```python
params = {
    "symbols": "BTCUSDT_PERP.A",
    "interval": "1hour",              # 必须完整拼写
    "from": int(time.time()) - 3600,  # UNIX 秒 ⚠️
    "to": int(time.time())            # UNIX 秒 ⚠️
}
```

**Coinalyze API 响应示例** (2026-01-26 服务器实测):

```json
// GET /v1/open-interest?symbols=BTCUSDT_PERP.A
[{
    "symbol": "BTCUSDT_PERP.A",
    "value": 102726.971,              // ⚠️ BTC 数量，不是 USD!
    "update": 1769420176882           // ⚠️ 毫秒 (13位)!
}]

// GET /v1/funding-rate?symbols=BTCUSDT_PERP.A
[{
    "symbol": "BTCUSDT_PERP.A",
    "value": 0.002847,                // 0.2847%
    "update": 1769420174380           // ⚠️ 毫秒 (13位)!
}]

// GET /v1/liquidation-history?symbols=BTCUSDT_PERP.A&interval=1hour&from=1769416578&to=1769420178
// ⚠️ 响应是嵌套结构，不是扁平数组!
[{
    "symbol": "BTCUSDT_PERP.A",
    "history": [                      // ⚠️ 嵌套在 history 数组内!
        {
            "t": 1769418000,          // 秒 (10位)
            "l": 0.832,               // long liquidation (单位待确认)
            "s": 0                    // short liquidation
        }
    ]
}]

// GET /v1/open-interest-history?symbols=BTCUSDT_PERP.A&interval=1hour&from=...&to=...
// ⚠️ 返回 OHLC 数据!
[{
    "symbol": "BTCUSDT_PERP.A",
    "history": [
        {
            "t": 1769335200,          // 秒 (10位)
            "o": 100145.378,          // open (BTC)
            "h": 100333.515,          // high (BTC)
            "l": 100143.96,           // low (BTC)
            "c": 100284.726           // close (BTC) ⭐ 使用这个
        },
        // ... 更多 OHLC 数据
    ]
}]
```

**注意事项**:
1. ⚠️ **时间戳单位不一致**: 当前端点用毫秒，历史端点用秒
2. ⚠️ **Liquidation 是嵌套结构**: 需要从 `response[0].history` 提取
3. ⚠️ **OI History 是 OHLC**: 使用 `c` (close) 字段获取 OI 值
4. ⚠️ OI 的 `value` 是 **BTC 数量**，需要乘以当前价格才能得到 USD 值
5. ⚠️ Funding Rate 的 `value` 是小数形式 (0.002847 = 0.2847%)
6. `change_24h_pct` 需要从 OI History 计算 (对比 24h 前的 `c` 值)
7. `predicted` funding rate API 不提供，代码中设为 0

**历史数据保留策略**:
- 日内周期 (1min ~ 12hour): 保留 1500-2000 条，每日删除旧数据
- 日线周期 (daily): 永久保留

**速率限制**:
- 40 次/分钟/API Key
- 超限返回 HTTP 429
- `Retry-After` header 指示等待秒数

### 9.7 配置项扩展

#### 9.7.1 敏感信息 (~/.env.aitrader)

```bash
# === 新增 Coinalyze API Key ===
COINALYZE_API_KEY=your_api_key_here  # 从 coinalyze.net 获取免费 API Key

# === 已有配置 (保持不变) ===
BINANCE_API_KEY=xxx
BINANCE_API_SECRET=xxx
DEEPSEEK_API_KEY=xxx
TELEGRAM_BOT_TOKEN=xxx
TELEGRAM_CHAT_ID=xxx
```

#### 9.7.2 完整配置 (configs/base.yaml)

在 `configs/base.yaml` 末尾添加以下配置:

```yaml
# =============================================================================
# 多时间框架配置 (Multi-Timeframe Framework) v3.2
# =============================================================================
multi_timeframe:
  enabled: false                      # 默认禁用，确保向后兼容

  # ---------------------------------------------------------------------------
  # 趋势层配置 (1D) - Risk-On/Risk-Off 判断
  # ---------------------------------------------------------------------------
  trend_layer:
    timeframe: "1d"
    sma_period: 200                   # SMA_200 判断长期趋势
    require_above_sma: true           # 价格需在 SMA 上方才能交易
    require_macd_positive: true       # MACD > 0 才能交易
    cache_ttl_hours: 4                # 趋势状态缓存时间

  # ---------------------------------------------------------------------------
  # 决策层配置 (4H) - Bull/Bear 辩论决定方向
  # ---------------------------------------------------------------------------
  decision_layer:
    timeframe: "4h"
    debate_rounds: 2                  # TradingAgents 辩论轮数
    include_trend_context: true       # 在辩论中包含趋势层信息
    indicators:
      sma_periods: [20, 50]
      rsi_period: 14
      macd_fast: 12
      macd_slow: 26
      bb_period: 20
      bb_std: 2.0

  # ---------------------------------------------------------------------------
  # 执行层配置 (5M / 15M) - 精确入场时机
  # ---------------------------------------------------------------------------
  execution_layer:
    default_timeframe: "15m"          # 默认执行周期
    high_volatility_timeframe: "5m"   # 高波动时使用 5M
    rsi_entry_min: 35                 # RSI 入场范围下限
    rsi_entry_max: 65                 # RSI 入场范围上限
    indicators:
      sma_periods: [5, 20]
      ema_periods: [10]
      rsi_period: 14
      support_resistance_lookback: 20

# =============================================================================
# 订单流数据配置 (Order Flow) v3.2
# =============================================================================
order_flow:
  enabled: true                       # 启用订单流数据增强

  # ---------------------------------------------------------------------------
  # Binance K线完整字段
  # ---------------------------------------------------------------------------
  binance:
    use_taker_data: true              # 使用 taker_buy_volume (列[9])
    use_quote_volume: true            # 使用 quote_volume (列[7])
    use_trades_count: true            # 使用 trades_count (列[8])
    bars_for_analysis: 10             # 分析最近 N 根 K线

  # ---------------------------------------------------------------------------
  # Coinalyze 衍生品数据 (需要 API Key)
  # ---------------------------------------------------------------------------
  coinalyze:
    enabled: true                     # 启用 Coinalyze 数据
    api_key: ""                       # 从 ~/.env.aitrader 的 COINALYZE_API_KEY 读取
    timeout: 10                       # API 请求超时 (秒)
    symbol: "BTCUSDT_PERP.A"          # Coinalyze Symbol 格式 (A=Binance)
    endpoints:
      open_interest: true
      liquidations: true
      funding_rate: true
    # 降级策略: API 失败时使用默认值
    fallback_enabled: true
    fallback_oi_usd: 0
    fallback_funding_rate: 0

  # ---------------------------------------------------------------------------
  # 买卖比阈值
  # ---------------------------------------------------------------------------
  buy_ratio:
    bullish_threshold: 0.55           # >55% 视为多头主导
    bearish_threshold: 0.45           # <45% 视为空头主导
    trend_threshold: 0.01             # 趋势判断阈值 (前5根 vs 后5根差值)

  # ---------------------------------------------------------------------------
  # Prompt 配置
  # ---------------------------------------------------------------------------
  prompt:
    version: "optimized"              # "optimized" (~600 tokens) 或 "full" (~1800 tokens)
    include_interpretation_guide: true # 在 Prompt 中包含解读指南
    weights:                          # 各数据权重 (供 AI 参考)
      order_flow: 0.30
      technical: 0.25
      derivatives: 0.25
      sentiment: 0.20
```

#### 9.7.3 环境覆盖 (configs/production.yaml)

```yaml
# 生产环境: 启用多时间框架
multi_timeframe:
  enabled: true
  execution_layer:
    default_timeframe: "15m"

order_flow:
  enabled: true
  coinalyze:
    enabled: true
```

#### 9.7.4 环境覆盖 (configs/development.yaml)

```yaml
# 开发环境: 使用更短周期便于测试
multi_timeframe:
  enabled: true
  trend_layer:
    timeframe: "4h"                   # 开发用 4H 代替 1D
    sma_period: 50                    # 开发用 SMA_50 代替 SMA_200
  decision_layer:
    timeframe: "1h"                   # 开发用 1H 代替 4H
  execution_layer:
    default_timeframe: "5m"           # 开发用 5M 代替 15M

order_flow:
  enabled: true
  binance:
    bars_for_analysis: 5              # 开发用 5 根代替 10 根
  coinalyze:
    enabled: false                    # 开发环境可禁用 Coinalyze
```

#### 9.7.5 代码中读取配置

```python
# main_live.py 中加载配置
from utils.config_manager import ConfigManager
import os

config = ConfigManager(env='production')
config.load()

# 多时间框架配置
mtf_enabled = config.get('multi_timeframe', 'enabled', default=False)
trend_sma_period = config.get('multi_timeframe', 'trend_layer', 'sma_period', default=200)
decision_timeframe = config.get('multi_timeframe', 'decision_layer', 'timeframe', default='4h')

# 订单流配置
order_flow_enabled = config.get('order_flow', 'enabled', default=True)
coinalyze_enabled = config.get('order_flow', 'coinalyze', 'enabled', default=True)
coinalyze_symbol = config.get('order_flow', 'coinalyze', 'symbol', default='BTCUSDT_PERP.A')

# Coinalyze API Key (从环境变量)
coinalyze_api_key = os.getenv('COINALYZE_API_KEY', '')

# 初始化 Coinalyze 客户端
from utils.coinalyze_client import CoinalyzeClient
coinalyze_client = CoinalyzeClient(
    api_key=coinalyze_api_key,
    timeout=config.get('order_flow', 'coinalyze', 'timeout', default=10)
)
```

### 9.8 实施计划 (v3.2.5 更新)

#### 9.8.1 全面审查结论

| 维度 | 得分 | 状态 |
|------|------|------|
| 当前系统匹配度 | 8.5/10 | ✅ 高度兼容 |
| NautilusTrader 标准 | 89% | ✅ 符合 |
| TradingAgents 设计理念 | 87% | ✅ 符合 |
| 数据格式一致性 | 100% | ✅ 已同步 |

#### 9.8.2 实施前准备清单

**环境准备** (必须先完成):

```bash
# 1. 添加 Coinalyze API Key 到服务器
ssh linuxuser@139.180.157.152
echo 'COINALYZE_API_KEY=8be2c53d-480f-4347-b7cf-d9f2b06576fa' >> ~/.env.aitrader

# 2. 验证配置
cat ~/.env.aitrader | grep COINALYZE

# 3. 验证 API 连通性 (在本地开发环境)
cd /home/user/AItrader
python3 scripts/test_coinalyze_api.py
```

#### 9.8.3 详细执行顺序

```
================================================================================
                        多时间框架实施执行计划
================================================================================

阶段 0: 环境准备 [预计 30 分钟]
├── [0.1] 添加 COINALYZE_API_KEY 到 ~/.env.aitrader
├── [0.2] 运行 test_coinalyze_api.py 验证 API 连通性
└── [0.3] 确认所有 API 端点返回正确格式

阶段 1: 配置扩展 [预计 1 小时]
├── [1.1] configs/base.yaml
│   ├── 添加 multi_timeframe 配置节 (~50 行)
│   └── 添加 order_flow 配置节 (~30 行)
├── [1.2] CLAUDE.md
│   └── 添加 COINALYZE_API_KEY 说明
└── [1.3] 验证配置加载
    └── python3 main_live.py --env development --dry-run

阶段 2: 核心模块创建 [预计 6-8 小时]
├── [2.1] indicators/multi_timeframe_manager.py [~300 行]
│   ├── RiskState 枚举 (RISK_ON, RISK_OFF)
│   ├── DecisionState 枚举 (ALLOW_LONG, ALLOW_SHORT, WAIT)
│   ├── MultiTimeframeManager 类
│   │   ├── route_bar(bar_type) → str
│   │   ├── evaluate_trend_layer(tech_data_1d) → RiskState
│   │   ├── evaluate_decision_layer(tech_data_4h, sentiment) → DecisionState
│   │   ├── check_execution_confirmation(tech_data_15m) → bool
│   │   └── get_final_action() → str
│   └── 单元测试: tests/test_multi_timeframe_manager.py
│
├── [2.2] utils/coinalyze_client.py [~150 行]
│   ├── CoinalyzeClient 类 (从方案 Section 9.6.2 复制)
│   ├── get_open_interest() - 返回 value (BTC) + update (秒)
│   ├── get_funding_rate() - 返回 value
│   ├── get_liquidations() - 返回 t, l, s
│   └── 单元测试: tests/test_coinalyze_client.py
│
├── [2.3] utils/order_flow_processor.py [~80 行]
│   ├── OrderFlowProcessor 类 (从方案 Section 9.6.1 复制)
│   ├── process_klines(klines) → order_flow 数据
│   └── 单元测试: tests/test_order_flow.py
│
└── [2.4] utils/ai_data_assembler.py [~150 行]
    ├── AIDataAssembler 类 (从方案 Section 9.6.3 复制)
    ├── assemble(klines, technical, position) → ai_input_data
    ├── _convert_derivatives(oi, liq, funding, price) → 统一格式
    └── 单元测试: tests/test_ai_data_assembler.py

阶段 3: 策略集成 [预计 4-6 小时]
├── [3.1] strategy/deepseek_strategy.py - 配置扩展
│   ├── DeepSeekAIStrategyConfig 添加 multi_timeframe 字段
│   └── __init__() 初始化 MultiTimeframeManager
│
├── [3.2] strategy/deepseek_strategy.py - 订阅修改
│   └── on_start() 订阅 3 个 bar_type (1D, 4H, 15M)
│
├── [3.3] strategy/deepseek_strategy.py - 路由逻辑
│   ├── on_bar() 添加 route_bar() 路由
│   ├── _handle_1d_bar() - 趋势层处理
│   ├── _handle_4h_bar() - 决策层处理
│   └── _handle_15m_bar() - 执行层处理
│
└── [3.4] main_live.py - 配置读取
    └── get_strategy_config() 添加 multi_timeframe 配置读取

阶段 4: 测试验证 [预计 3-4 小时]
├── [4.1] 单元测试
│   ├── pytest tests/test_multi_timeframe_manager.py -v
│   ├── pytest tests/test_coinalyze_client.py -v
│   ├── pytest tests/test_order_flow.py -v
│   └── pytest tests/test_ai_data_assembler.py -v
│
├── [4.2] 集成测试
│   ├── python3 scripts/test_coinalyze_api.py
│   ├── python3 scripts/diagnose_realtime.py --include-mtf
│   └── python3 main_live.py --env development --dry-run
│
├── [4.3] 回归测试
│   └── python3 scripts/smart_commit_analyzer.py
│
└── [4.4] 生产验证
    ├── 开发环境 dry-run 24 小时
    └── 检查日志无异常后启用生产

================================================================================
```

#### 9.8.4 工作量估算

| 阶段 | 内容 | 代码行数 | 预计时间 |
|------|------|---------|---------|
| **阶段 0** | 环境准备 | 0 | 30 分钟 |
| **阶段 1** | 配置扩展 | ~85 行 | 1 小时 |
| **阶段 2** | 核心模块 | ~680 行 | 6-8 小时 |
| **阶段 3** | 策略集成 | ~200 行 | 4-6 小时 |
| **阶段 4** | 测试验证 | ~300 行 | 3-4 小时 |
| **总计** | | ~1265 行 | **15-20 小时** |

#### 9.8.5 风险评估

| 风险 | 等级 | 缓解措施 |
|------|------|---------|
| 循环依赖 | 🟡 中 | 使用组合模式，避免导入策略类 |
| 线程安全 | 🟡 中 | 使用现有 _state_lock 保护 MTF 状态 |
| 指标初始化 | 🟡 中 | on_start() 预取历史数据 |
| API 失败 | 🟢 低 | Coinalyze 失败时使用默认值 (0) |
| 向后兼容 | 🟢 低 | `multi_timeframe.enabled: false` 禁用新功能 |

#### 9.8.6 回滚方案

```yaml
# 如需回滚，只需在 configs/base.yaml 设置:
multi_timeframe:
  enabled: false  # 禁用多时间框架，恢复单一 15M 模式

order_flow:
  enabled: false  # 禁用订单流数据
```

### 9.9 验证方法

```bash
# 1. 环境验证
cat ~/.env.aitrader | grep COINALYZE
python3 scripts/test_coinalyze_api.py

# 2. 单元测试
python3 -m pytest tests/test_multi_timeframe_manager.py -v
python3 -m pytest tests/test_coinalyze_client.py -v
python3 -m pytest tests/test_order_flow.py -v

# 3. 集成测试
python3 scripts/diagnose_realtime.py --include-mtf

# 4. 回归检测
python3 scripts/smart_commit_analyzer.py

# 5. 配置验证
python3 main_live.py --env development --dry-run

# 6. 生产前验证
python3 main_live.py --env production --dry-run
```

### 9.10 文件创建清单

**需要新建的文件**:

| 文件路径 | 来源 | 优先级 |
|---------|------|--------|
| `indicators/multi_timeframe_manager.py` | 新建 | 🔴 高 |
| `utils/coinalyze_client.py` | Section 9.6.2 | 🔴 高 |
| `utils/order_flow_processor.py` | Section 9.6.1 | 🔴 高 |
| `utils/ai_data_assembler.py` | Section 9.6.3 | 🔴 高 |
| `tests/test_multi_timeframe_manager.py` | Section 5.1 | 🟡 中 |
| `tests/test_coinalyze_client.py` | 新建 | 🟡 中 |
| `tests/test_order_flow.py` | 新建 | 🟡 中 |
| `scripts/diagnose_coinalyze.py` | Section 4.1 | 🟡 中 |

**需要修改的文件**:

| 文件路径 | 修改内容 | 优先级 |
|---------|---------|--------|
| `configs/base.yaml` | 添加 multi_timeframe + order_flow 配置 | 🔴 高 |
| `strategy/deepseek_strategy.py` | 集成 MTF Manager | 🔴 高 |
| `main_live.py` | 读取新配置 | 🔴 高 |
| `CLAUDE.md` | 添加 COINALYZE_API_KEY 说明 | 🟢 低 |

---

*文档更新于 2026-01-26 v3.2.5 - 全面审查 + 详细执行计划*
