"""
Configuration Checker Module

Validates critical configurations that could prevent trading.
"""

import os
import re
import sys
from pathlib import Path
from typing import List, Tuple

import yaml

from .base import DiagnosticContext, DiagnosticStep, mask_sensitive


class CriticalConfigChecker(DiagnosticStep):
    """
    Check critical configurations that could prevent orders from executing.

    Validates:
    - main_live.py: load_all and reconciliation settings
    - deepseek_strategy.py: SL/TP field names
    - trading_logic.py: MIN_SL_DISTANCE_PCT
    - patches: Binance enum patches
    """

    name = "å…³é”®é…ç½®æ£€æŸ¥"

    def run(self) -> bool:
        print("-" * 70)
        issues, warnings = self._check_critical_config()

        if issues:
            print()
            print("  ğŸš¨ å‘ç°ä¸¥é‡é—®é¢˜ (å¯èƒ½å¯¼è‡´ä¸èƒ½ä¸‹å•):")
            print()
            for issue in issues:
                for line in issue.split('\n'):
                    print(f"  {line}")
                print()
            self.ctx.errors.extend([i.split('\n')[0] for i in issues])

        if warnings:
            print("  âš ï¸ è­¦å‘Š:")
            for warning in warnings:
                for line in warning.split('\n'):
                    print(f"     {line}")
            print()
            self.ctx.warnings.extend([w.split('\n')[0] for w in warnings])

        if not issues and not warnings:
            print("  âœ… load_all=True")
            print("  âœ… reconciliation=True")
            print("  âœ… SL/TP å­—æ®µåæ­£ç¡®")
            print("  âœ… æ‰€æœ‰å…³é”®é…ç½®æ£€æŸ¥é€šè¿‡")

        if issues:
            print("  " + "=" * 66)
            print("  â›” å‘ç°ä¸¥é‡é…ç½®é—®é¢˜! è¯·å…ˆä¿®å¤ä¸Šè¿°é—®é¢˜å†è¿è¡Œå®ç›˜äº¤æ˜“ã€‚")
            print("  " + "=" * 66)
            print()
            # In non-interactive mode, just warn and continue
            if sys.stdin.isatty():
                response = input("  æ˜¯å¦ç»§ç»­è¯Šæ–­? (y/N): ")
                if response.lower() != 'y':
                    print("  é€€å‡ºè¯Šæ–­ã€‚")
                    return False

        return len(issues) == 0

    def _check_critical_config(self) -> Tuple[List[str], List[str]]:
        """
        Check critical configuration settings.

        Returns:
            (issues, warnings): Lists of issues and warnings
        """
        issues = []
        warnings = []
        project_root = self.ctx.project_root

        # Check 1: main_live.py load_all and reconciliation
        self._check_main_live(project_root, issues, warnings)

        # Check 2: deepseek_strategy.py SL/TP field names
        self._check_strategy_fields(project_root, issues, warnings)

        # Check 3: trading_logic.py MIN_SL_DISTANCE_PCT
        self._check_trading_logic(project_root, issues, warnings)

        # Check 4: patches
        self._check_patches(project_root, issues, warnings)

        return issues, warnings

    def _check_main_live(
        self,
        project_root: Path,
        issues: List[str],
        warnings: List[str]
    ) -> None:
        """Check main_live.py configuration."""
        main_live_path = project_root / "main_live.py"

        if not main_live_path.exists():
            issues.append("âŒ main_live.py æ–‡ä»¶ä¸å­˜åœ¨!")
            return

        with open(main_live_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Check load_all
        load_all_matches = re.findall(r'load_all\s*=\s*(True|False)', content)
        if not load_all_matches:
            warnings.append("main_live.py: æœªæ‰¾åˆ° load_all é…ç½®")
        elif 'False' in load_all_matches:
            issues.append(
                "âŒ main_live.py: load_all=False\n"
                "   â†’ å¯èƒ½å¯¼è‡´ instrument åˆå§‹åŒ–ä¸å®Œæ•´ï¼Œè®¢å•æ— æ³•æ‰§è¡Œ\n"
                "   â†’ ä¿®å¤: æ”¹ä¸º load_all=True"
            )

        # Check reconciliation (supports two formats)
        reconciliation_hardcoded = re.findall(
            r'reconciliation\s*=\s*(True|False)', content
        )
        reconciliation_configmanager = re.search(
            r"config_manager\.get\s*\(\s*['\"]execution['\"].*['\"]reconciliation['\"].*default\s*=\s*(True|False)",
            content
        )

        if reconciliation_configmanager:
            if reconciliation_configmanager.group(1) == 'False':
                issues.append(
                    "âŒ main_live.py: reconciliation default=False\n"
                    "   â†’ ä»“ä½ä¸åŒæ­¥ï¼Œå¯èƒ½å¯¼è‡´è®¢å•ç®¡ç†å¼‚å¸¸\n"
                    "   â†’ ä¿®å¤: æ”¹ä¸º default=True"
                )
        elif reconciliation_hardcoded:
            if 'False' in reconciliation_hardcoded:
                issues.append(
                    "âŒ main_live.py: reconciliation=False\n"
                    "   â†’ ä»“ä½ä¸åŒæ­¥ï¼Œå¯èƒ½å¯¼è‡´è®¢å•ç®¡ç†å¼‚å¸¸\n"
                    "   â†’ ä¿®å¤: æ”¹ä¸º reconciliation=True"
                )
        else:
            warnings.append("main_live.py: æœªæ‰¾åˆ° reconciliation é…ç½®")

    def _check_strategy_fields(
        self,
        project_root: Path,
        issues: List[str],
        warnings: List[str]
    ) -> None:
        """Check deepseek_strategy.py SL/TP field names."""
        strategy_path = project_root / "strategy" / "deepseek_strategy.py"

        if not strategy_path.exists():
            warnings.append("deepseek_strategy.py æ–‡ä»¶ä¸å­˜åœ¨")
            return

        with open(strategy_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Check for incorrect field names
        if "stop_loss_multi" in content:
            issues.append(
                "âŒ deepseek_strategy.py: ä½¿ç”¨äº† 'stop_loss_multi' å­—æ®µå\n"
                "   â†’ MultiAgent è¿”å›çš„å­—æ®µåæ˜¯ 'stop_loss'\n"
                "   â†’ è¿™ä¼šå¯¼è‡´ SL å€¼æ°¸è¿œä¸º None\n"
                "   â†’ ä¿®å¤: æ”¹ä¸º .get('stop_loss')"
            )

        if "take_profit_multi" in content:
            issues.append(
                "âŒ deepseek_strategy.py: ä½¿ç”¨äº† 'take_profit_multi' å­—æ®µå\n"
                "   â†’ MultiAgent è¿”å›çš„å­—æ®µåæ˜¯ 'take_profit'\n"
                "   â†’ è¿™ä¼šå¯¼è‡´ TP å€¼æ°¸è¿œä¸º None\n"
                "   â†’ ä¿®å¤: æ”¹ä¸º .get('take_profit')"
            )

        # Check correct field names exist
        if not re.search(r"\.get\(['\"]stop_loss['\"]\)", content):
            warnings.append("deepseek_strategy.py: æœªæ‰¾åˆ° .get('stop_loss') è°ƒç”¨")
        if not re.search(r"\.get\(['\"]take_profit['\"]\)", content):
            warnings.append("deepseek_strategy.py: æœªæ‰¾åˆ° .get('take_profit') è°ƒç”¨")

    def _check_trading_logic(
        self,
        project_root: Path,
        issues: List[str],
        warnings: List[str]
    ) -> None:
        """Check trading_logic.py MIN_SL_DISTANCE_PCT."""
        trading_logic_path = project_root / "strategy" / "trading_logic.py"

        if not trading_logic_path.exists():
            return

        with open(trading_logic_path, 'r', encoding='utf-8') as f:
            content = f.read()

        min_sl_match = re.search(
            r'MIN_SL_DISTANCE_PCT\s*=\s*([\d.]+)', content
        )
        if not min_sl_match:
            warnings.append(
                "trading_logic.py: æœªæ‰¾åˆ° MIN_SL_DISTANCE_PCT\n"
                "   â†’ SL è·ç¦»éªŒè¯å¯èƒ½ä¸ç”Ÿæ•ˆ"
            )
        else:
            min_sl_pct = float(min_sl_match.group(1))
            if min_sl_pct < 0.01:
                warnings.append(
                    f"trading_logic.py: MIN_SL_DISTANCE_PCT={min_sl_pct}\n"
                    f"   â†’ å»ºè®®è‡³å°‘è®¾ç½®ä¸º 0.01 (1%)"
                )

        # Check multi_agent_analyzer.py imports
        analyzer_path = project_root / "agents" / "multi_agent_analyzer.py"
        if analyzer_path.exists():
            with open(analyzer_path, 'r', encoding='utf-8') as f:
                analyzer_content = f.read()

            has_import = "from strategy.trading_logic import" in analyzer_content
            has_constant = "MIN_SL_DISTANCE_PCT" in analyzer_content
            has_getter = "get_min_sl_distance_pct" in analyzer_content

            if not (has_import and (has_constant or has_getter)):
                warnings.append(
                    "multi_agent_analyzer.py: æœªä» trading_logic å¯¼å…¥ SL éªŒè¯å‡½æ•°/å¸¸é‡\n"
                    "   â†’ åº”å¯¼å…¥ get_min_sl_distance_pct() æˆ– MIN_SL_DISTANCE_PCT"
                )

    def _check_patches(
        self,
        project_root: Path,
        issues: List[str],
        warnings: List[str]
    ) -> None:
        """Check if patches are properly set up."""
        binance_enums = project_root / "patches" / "binance_enums.py"
        if not binance_enums.exists():
            warnings.append(
                "patches/binance_enums.py ä¸å­˜åœ¨ - å¯èƒ½ç¼ºå°‘æšä¸¾å…¼å®¹æ€§è¡¥ä¸"
            )


class MTFConfigChecker(DiagnosticStep):
    """
    Check Multi-Timeframe configuration.

    Validates:
    - MTF enabled status
    - Trend/Decision/Execution layer configuration
    - Order Flow configuration
    - Initialization settings
    """

    name = "MTF å¤šæ—¶é—´æ¡†æ¶é…ç½®æ£€æŸ¥"

    def run(self) -> bool:
        print("-" * 70)

        try:
            mtf_config_path = self.ctx.project_root / "configs" / "base.yaml"

            if not mtf_config_path.exists():
                self.ctx.add_warning("configs/base.yaml ä¸å­˜åœ¨ï¼Œè·³è¿‡ MTF æ£€æŸ¥")
                return True

            with open(mtf_config_path, 'r', encoding='utf-8') as f:
                self.ctx.base_config = yaml.safe_load(f)

            # Load thresholds from config
            self.ctx.load_thresholds_from_config()

            mtf_config = self.ctx.base_config.get('multi_timeframe', {})
            mtf_enabled = mtf_config.get('enabled', False)

            if mtf_enabled:
                self._display_mtf_config(mtf_config)
                self._check_mtf_manager()
            else:
                print("  â„¹ï¸ MTF å¤šæ—¶é—´æ¡†æ¶: æœªå¯ç”¨")
                print("     â†’ å¦‚éœ€å¯ç”¨ï¼Œç¼–è¾‘ configs/base.yaml:")
                print("       multi_timeframe:")
                print("         enabled: true")

            # Check Order Flow config
            self._check_order_flow_config()

            return True

        except Exception as e:
            self.ctx.add_warning(f"MTF é…ç½®æ£€æŸ¥å¤±è´¥: {e}")
            return True  # Non-critical, continue

    def _display_mtf_config(self, mtf_config: dict) -> None:
        """Display MTF configuration details."""
        print("  âœ… MTF å¤šæ—¶é—´æ¡†æ¶: å·²å¯ç”¨")

        # Trend layer (1D)
        trend_layer = mtf_config.get('trend_layer', {})
        trend_tf = trend_layer.get('timeframe', 'N/A')
        trend_sma = trend_layer.get('sma_period', 200)
        print(f"     è¶‹åŠ¿å±‚ (Trend): {trend_tf} (SMA_{trend_sma})")
        if 'require_above_sma' in trend_layer:
            print(f"       require_above_sma: {trend_layer['require_above_sma']}")
        if 'require_macd_positive' in trend_layer:
            print(f"       require_macd_positive: {trend_layer['require_macd_positive']}")

        # Decision layer (4H)
        decision_layer = mtf_config.get('decision_layer', {})
        decision_tf = decision_layer.get('timeframe', 'N/A')
        print(f"     å†³ç­–å±‚ (Decision): {decision_tf}")
        if 'debate_rounds' in decision_layer:
            print(f"       debate_rounds: {decision_layer['debate_rounds']}")
        if 'include_trend_context' in decision_layer:
            print(f"       include_trend_context: {decision_layer['include_trend_context']}")

        # Execution layer (15M)
        execution_layer = mtf_config.get('execution_layer', {})
        execution_tf = execution_layer.get('default_timeframe', 'N/A')
        print(f"     æ‰§è¡Œå±‚ (Execution): {execution_tf}")
        if 'rsi_entry_min' in execution_layer:
            print(f"       RSI å…¥åœºèŒƒå›´: {execution_layer.get('rsi_entry_min', 30)}-{execution_layer.get('rsi_entry_max', 70)}")

        # Initialization config
        init_cfg = mtf_config.get('initialization', {})
        if init_cfg:
            print("  âœ… MTF åˆå§‹åŒ–é…ç½®å­˜åœ¨")
            print(f"     trend_min_bars: {init_cfg.get('trend_min_bars', 'N/A')}")
            print(f"     decision_min_bars: {init_cfg.get('decision_min_bars', 'N/A')}")
            print(f"     execution_min_bars: {init_cfg.get('execution_min_bars', 'N/A')}")
        else:
            print("  âš ï¸ MTF initialization é…ç½®æ®µä¸å­˜åœ¨")
            print("     â†’ å°†ä½¿ç”¨é»˜è®¤å€¼ (220/60/40 bars)")

    def _check_mtf_manager(self) -> None:
        """Check MultiTimeframeManager module."""
        mtf_manager_path = self.ctx.project_root / "indicators" / "multi_timeframe_manager.py"

        if mtf_manager_path.exists():
            print("  âœ… MultiTimeframeManager æ¨¡å—å­˜åœ¨")
            try:
                from indicators.multi_timeframe_manager import MultiTimeframeManager
                print("  âœ… MultiTimeframeManager å¯¼å…¥æˆåŠŸ")
                print("     v3.3: ä¸‰å±‚æ•°æ®æ”¶é›† (1D/4H/15M)ï¼Œå†³ç­–é€»è¾‘ç”± AI æ§åˆ¶")
            except ImportError as e:
                self.ctx.add_warning(f"MultiTimeframeManager å¯¼å…¥å¤±è´¥: {e}")
        else:
            self.ctx.add_error("MultiTimeframeManager æ¨¡å—ä¸å­˜åœ¨!")
            print("     â†’ é¢„æœŸè·¯å¾„: indicators/multi_timeframe_manager.py")

    def _check_order_flow_config(self) -> None:
        """Check Order Flow configuration."""
        order_flow = self.ctx.base_config.get('order_flow', {})
        order_flow_enabled = order_flow.get('enabled', False)

        print()
        if order_flow_enabled:
            print("  âœ… Order Flow: å·²å¯ç”¨")
            binance_of = order_flow.get('binance', {})
            coinalyze = order_flow.get('coinalyze', {})
            print(f"     Binance enabled: {binance_of.get('enabled', False)}")
            print(f"     Coinalyze enabled: {coinalyze.get('enabled', False)}")

            # Check Coinalyze API key
            coinalyze_api_key = coinalyze.get('api_key') or os.getenv('COINALYZE_API_KEY')
            if coinalyze.get('enabled') and not coinalyze_api_key:
                print("     âš ï¸ Coinalyze å·²å¯ç”¨ä½†ç¼ºå°‘ API key")
            elif coinalyze.get('enabled') and coinalyze_api_key:
                print(f"     âœ… Coinalyze API key: {mask_sensitive(coinalyze_api_key)}")
        else:
            print("  â„¹ï¸ Order Flow: æœªå¯ç”¨")


class StrategyConfigLoader(DiagnosticStep):
    """
    Load strategy configuration from main_live.py.

    Uses the same initialization flow as the production system.
    """

    name = "ä» main_live.py åŠ è½½çœŸå®é…ç½®"

    def run(self) -> bool:
        try:
            # Add project root to path
            if str(self.ctx.project_root) not in sys.path:
                sys.path.insert(0, str(self.ctx.project_root))

            # Apply patches (same as main_live.py)
            from patches.binance_enums import apply_all_patches
            apply_all_patches()

            # Load environment variables (same as main_live.py)
            from dotenv import load_dotenv
            env_permanent = Path.home() / ".env.aitrader"
            env_local = self.ctx.project_root / ".env"

            if env_permanent.exists():
                load_dotenv(env_permanent)
            elif env_local.exists():
                load_dotenv(env_local)
            else:
                load_dotenv()

            # Load strategy config
            from main_live import get_strategy_config
            from utils.config_manager import ConfigManager

            config_manager = ConfigManager(env=self.ctx.env)
            config_manager.load()

            self.ctx.strategy_config = get_strategy_config(config_manager)

            # Display config
            cfg = self.ctx.strategy_config
            if not self.ctx.summary_mode:
                print(f"  instrument_id: {cfg.instrument_id}")
                print(f"  bar_type: {cfg.bar_type}")
                print(f"  equity: ${cfg.equity}")
                print(f"  base_usdt_amount: ${cfg.base_usdt_amount}")
                print(f"  leverage: {cfg.leverage}x")
                print(f"  min_confidence_to_trade: {cfg.min_confidence_to_trade}")
                timer_sec = cfg.timer_interval_sec
                timer_min = timer_sec / 60
                print(f"  timer_interval_sec: {timer_sec}s ({timer_min:.1f}åˆ†é’Ÿ)")
                print(f"  sma_periods: {list(cfg.sma_periods)}")
                print(f"  rsi_period: {cfg.rsi_period}")
                print(f"  macd_fast/slow: {cfg.macd_fast}/{cfg.macd_slow}")
                print(f"  debate_rounds: {cfg.debate_rounds}")
                print("  âœ… é…ç½®åŠ è½½æˆåŠŸ (ä¸å®ç›˜å®Œå…¨ä¸€è‡´)")
                print()
                print(f"  â° æ³¨æ„: å®ç›˜æ¯ {timer_min:.0f} åˆ†é’Ÿåˆ†æä¸€æ¬¡")
                print("     å¦‚æœåˆšå¯åŠ¨æœåŠ¡ï¼Œéœ€ç­‰å¾…ç¬¬ä¸€ä¸ªå‘¨æœŸè§¦å‘")

            # Parse symbol and interval
            from .base import parse_bar_interval, extract_symbol
            self.ctx.symbol = extract_symbol(cfg.instrument_id)
            self.ctx.interval = parse_bar_interval(str(cfg.bar_type))

            return True

        except Exception as e:
            self.ctx.add_error(f"é…ç½®åŠ è½½å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
            return False

    def should_skip(self) -> bool:
        # Never skip - all other steps depend on strategy_config
        return False
